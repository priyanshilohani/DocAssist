"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/parchment";
exports.ids = ["vendor-chunks/parchment"];
exports.modules = {

/***/ "(ssr)/./node_modules/parchment/dist/parchment.js":
/*!**************************************************!*\
  !*** ./node_modules/parchment/dist/parchment.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Attributor: () => (/* binding */ Attributor),\n/* harmony export */   AttributorStore: () => (/* binding */ AttributorStore$1),\n/* harmony export */   BlockBlot: () => (/* binding */ BlockBlot$1),\n/* harmony export */   ClassAttributor: () => (/* binding */ ClassAttributor$1),\n/* harmony export */   ContainerBlot: () => (/* binding */ ContainerBlot$1),\n/* harmony export */   EmbedBlot: () => (/* binding */ EmbedBlot$1),\n/* harmony export */   InlineBlot: () => (/* binding */ InlineBlot$1),\n/* harmony export */   LeafBlot: () => (/* binding */ LeafBlot$1),\n/* harmony export */   ParentBlot: () => (/* binding */ ParentBlot$1),\n/* harmony export */   Registry: () => (/* binding */ Registry),\n/* harmony export */   Scope: () => (/* binding */ Scope),\n/* harmony export */   ScrollBlot: () => (/* binding */ ScrollBlot$1),\n/* harmony export */   StyleAttributor: () => (/* binding */ StyleAttributor$1),\n/* harmony export */   TextBlot: () => (/* binding */ TextBlot$1)\n/* harmony export */ });\nvar Scope = /* @__PURE__ */ ((Scope2) => (Scope2[Scope2.TYPE = 3] = \"TYPE\", Scope2[Scope2.LEVEL = 12] = \"LEVEL\", Scope2[Scope2.ATTRIBUTE = 13] = \"ATTRIBUTE\", Scope2[Scope2.BLOT = 14] = \"BLOT\", Scope2[Scope2.INLINE = 7] = \"INLINE\", Scope2[Scope2.BLOCK = 11] = \"BLOCK\", Scope2[Scope2.BLOCK_BLOT = 10] = \"BLOCK_BLOT\", Scope2[Scope2.INLINE_BLOT = 6] = \"INLINE_BLOT\", Scope2[Scope2.BLOCK_ATTRIBUTE = 9] = \"BLOCK_ATTRIBUTE\", Scope2[Scope2.INLINE_ATTRIBUTE = 5] = \"INLINE_ATTRIBUTE\", Scope2[Scope2.ANY = 15] = \"ANY\", Scope2))(Scope || {});\nclass Attributor {\n  constructor(attrName, keyName, options = {}) {\n    this.attrName = attrName, this.keyName = keyName;\n    const attributeBit = Scope.TYPE & Scope.ATTRIBUTE;\n    this.scope = options.scope != null ? (\n      // Ignore type bits, force attribute bit\n      options.scope & Scope.LEVEL | attributeBit\n    ) : Scope.ATTRIBUTE, options.whitelist != null && (this.whitelist = options.whitelist);\n  }\n  static keys(node) {\n    return Array.from(node.attributes).map((item) => item.name);\n  }\n  add(node, value) {\n    return this.canAdd(node, value) ? (node.setAttribute(this.keyName, value), !0) : !1;\n  }\n  canAdd(_node, value) {\n    return this.whitelist == null ? !0 : typeof value == \"string\" ? this.whitelist.indexOf(value.replace(/[\"']/g, \"\")) > -1 : this.whitelist.indexOf(value) > -1;\n  }\n  remove(node) {\n    node.removeAttribute(this.keyName);\n  }\n  value(node) {\n    const value = node.getAttribute(this.keyName);\n    return this.canAdd(node, value) && value ? value : \"\";\n  }\n}\nclass ParchmentError extends Error {\n  constructor(message) {\n    message = \"[Parchment] \" + message, super(message), this.message = message, this.name = this.constructor.name;\n  }\n}\nconst _Registry = class _Registry {\n  constructor() {\n    this.attributes = {}, this.classes = {}, this.tags = {}, this.types = {};\n  }\n  static find(node, bubble = !1) {\n    if (node == null)\n      return null;\n    if (this.blots.has(node))\n      return this.blots.get(node) || null;\n    if (bubble) {\n      let parentNode = null;\n      try {\n        parentNode = node.parentNode;\n      } catch {\n        return null;\n      }\n      return this.find(parentNode, bubble);\n    }\n    return null;\n  }\n  create(scroll, input, value) {\n    const match2 = this.query(input);\n    if (match2 == null)\n      throw new ParchmentError(`Unable to create ${input} blot`);\n    const blotClass = match2, node = (\n      // @ts-expect-error Fix me later\n      input instanceof Node || input.nodeType === Node.TEXT_NODE ? input : blotClass.create(value)\n    ), blot = new blotClass(scroll, node, value);\n    return _Registry.blots.set(blot.domNode, blot), blot;\n  }\n  find(node, bubble = !1) {\n    return _Registry.find(node, bubble);\n  }\n  query(query, scope = Scope.ANY) {\n    let match2;\n    return typeof query == \"string\" ? match2 = this.types[query] || this.attributes[query] : query instanceof Text || query.nodeType === Node.TEXT_NODE ? match2 = this.types.text : typeof query == \"number\" ? query & Scope.LEVEL & Scope.BLOCK ? match2 = this.types.block : query & Scope.LEVEL & Scope.INLINE && (match2 = this.types.inline) : query instanceof Element && ((query.getAttribute(\"class\") || \"\").split(/\\s+/).some((name) => (match2 = this.classes[name], !!match2)), match2 = match2 || this.tags[query.tagName]), match2 == null ? null : \"scope\" in match2 && scope & Scope.LEVEL & match2.scope && scope & Scope.TYPE & match2.scope ? match2 : null;\n  }\n  register(...definitions) {\n    return definitions.map((definition) => {\n      const isBlot = \"blotName\" in definition, isAttr = \"attrName\" in definition;\n      if (!isBlot && !isAttr)\n        throw new ParchmentError(\"Invalid definition\");\n      if (isBlot && definition.blotName === \"abstract\")\n        throw new ParchmentError(\"Cannot register abstract class\");\n      const key = isBlot ? definition.blotName : isAttr ? definition.attrName : void 0;\n      return this.types[key] = definition, isAttr ? typeof definition.keyName == \"string\" && (this.attributes[definition.keyName] = definition) : isBlot && (definition.className && (this.classes[definition.className] = definition), definition.tagName && (Array.isArray(definition.tagName) ? definition.tagName = definition.tagName.map((tagName) => tagName.toUpperCase()) : definition.tagName = definition.tagName.toUpperCase(), (Array.isArray(definition.tagName) ? definition.tagName : [definition.tagName]).forEach((tag) => {\n        (this.tags[tag] == null || definition.className == null) && (this.tags[tag] = definition);\n      }))), definition;\n    });\n  }\n};\n_Registry.blots = /* @__PURE__ */ new WeakMap();\nlet Registry = _Registry;\nfunction match(node, prefix) {\n  return (node.getAttribute(\"class\") || \"\").split(/\\s+/).filter((name) => name.indexOf(`${prefix}-`) === 0);\n}\nclass ClassAttributor extends Attributor {\n  static keys(node) {\n    return (node.getAttribute(\"class\") || \"\").split(/\\s+/).map((name) => name.split(\"-\").slice(0, -1).join(\"-\"));\n  }\n  add(node, value) {\n    return this.canAdd(node, value) ? (this.remove(node), node.classList.add(`${this.keyName}-${value}`), !0) : !1;\n  }\n  remove(node) {\n    match(node, this.keyName).forEach((name) => {\n      node.classList.remove(name);\n    }), node.classList.length === 0 && node.removeAttribute(\"class\");\n  }\n  value(node) {\n    const value = (match(node, this.keyName)[0] || \"\").slice(this.keyName.length + 1);\n    return this.canAdd(node, value) ? value : \"\";\n  }\n}\nconst ClassAttributor$1 = ClassAttributor;\nfunction camelize(name) {\n  const parts = name.split(\"-\"), rest = parts.slice(1).map((part) => part[0].toUpperCase() + part.slice(1)).join(\"\");\n  return parts[0] + rest;\n}\nclass StyleAttributor extends Attributor {\n  static keys(node) {\n    return (node.getAttribute(\"style\") || \"\").split(\";\").map((value) => value.split(\":\")[0].trim());\n  }\n  add(node, value) {\n    return this.canAdd(node, value) ? (node.style[camelize(this.keyName)] = value, !0) : !1;\n  }\n  remove(node) {\n    node.style[camelize(this.keyName)] = \"\", node.getAttribute(\"style\") || node.removeAttribute(\"style\");\n  }\n  value(node) {\n    const value = node.style[camelize(this.keyName)];\n    return this.canAdd(node, value) ? value : \"\";\n  }\n}\nconst StyleAttributor$1 = StyleAttributor;\nclass AttributorStore {\n  constructor(domNode) {\n    this.attributes = {}, this.domNode = domNode, this.build();\n  }\n  attribute(attribute, value) {\n    value ? attribute.add(this.domNode, value) && (attribute.value(this.domNode) != null ? this.attributes[attribute.attrName] = attribute : delete this.attributes[attribute.attrName]) : (attribute.remove(this.domNode), delete this.attributes[attribute.attrName]);\n  }\n  build() {\n    this.attributes = {};\n    const blot = Registry.find(this.domNode);\n    if (blot == null)\n      return;\n    const attributes = Attributor.keys(this.domNode), classes = ClassAttributor$1.keys(this.domNode), styles = StyleAttributor$1.keys(this.domNode);\n    attributes.concat(classes).concat(styles).forEach((name) => {\n      const attr = blot.scroll.query(name, Scope.ATTRIBUTE);\n      attr instanceof Attributor && (this.attributes[attr.attrName] = attr);\n    });\n  }\n  copy(target) {\n    Object.keys(this.attributes).forEach((key) => {\n      const value = this.attributes[key].value(this.domNode);\n      target.format(key, value);\n    });\n  }\n  move(target) {\n    this.copy(target), Object.keys(this.attributes).forEach((key) => {\n      this.attributes[key].remove(this.domNode);\n    }), this.attributes = {};\n  }\n  values() {\n    return Object.keys(this.attributes).reduce(\n      (attributes, name) => (attributes[name] = this.attributes[name].value(this.domNode), attributes),\n      {}\n    );\n  }\n}\nconst AttributorStore$1 = AttributorStore, _ShadowBlot = class _ShadowBlot {\n  constructor(scroll, domNode) {\n    this.scroll = scroll, this.domNode = domNode, Registry.blots.set(domNode, this), this.prev = null, this.next = null;\n  }\n  static create(rawValue) {\n    if (this.tagName == null)\n      throw new ParchmentError(\"Blot definition missing tagName\");\n    let node, value;\n    return Array.isArray(this.tagName) ? (typeof rawValue == \"string\" ? (value = rawValue.toUpperCase(), parseInt(value, 10).toString() === value && (value = parseInt(value, 10))) : typeof rawValue == \"number\" && (value = rawValue), typeof value == \"number\" ? node = document.createElement(this.tagName[value - 1]) : value && this.tagName.indexOf(value) > -1 ? node = document.createElement(value) : node = document.createElement(this.tagName[0])) : node = document.createElement(this.tagName), this.className && node.classList.add(this.className), node;\n  }\n  // Hack for accessing inherited static methods\n  get statics() {\n    return this.constructor;\n  }\n  attach() {\n  }\n  clone() {\n    const domNode = this.domNode.cloneNode(!1);\n    return this.scroll.create(domNode);\n  }\n  detach() {\n    this.parent != null && this.parent.removeChild(this), Registry.blots.delete(this.domNode);\n  }\n  deleteAt(index, length) {\n    this.isolate(index, length).remove();\n  }\n  formatAt(index, length, name, value) {\n    const blot = this.isolate(index, length);\n    if (this.scroll.query(name, Scope.BLOT) != null && value)\n      blot.wrap(name, value);\n    else if (this.scroll.query(name, Scope.ATTRIBUTE) != null) {\n      const parent = this.scroll.create(this.statics.scope);\n      blot.wrap(parent), parent.format(name, value);\n    }\n  }\n  insertAt(index, value, def) {\n    const blot = def == null ? this.scroll.create(\"text\", value) : this.scroll.create(value, def), ref = this.split(index);\n    this.parent.insertBefore(blot, ref || void 0);\n  }\n  isolate(index, length) {\n    const target = this.split(index);\n    if (target == null)\n      throw new Error(\"Attempt to isolate at end\");\n    return target.split(length), target;\n  }\n  length() {\n    return 1;\n  }\n  offset(root = this.parent) {\n    return this.parent == null || this === root ? 0 : this.parent.children.offset(this) + this.parent.offset(root);\n  }\n  optimize(_context) {\n    this.statics.requiredContainer && !(this.parent instanceof this.statics.requiredContainer) && this.wrap(this.statics.requiredContainer.blotName);\n  }\n  remove() {\n    this.domNode.parentNode != null && this.domNode.parentNode.removeChild(this.domNode), this.detach();\n  }\n  replaceWith(name, value) {\n    const replacement = typeof name == \"string\" ? this.scroll.create(name, value) : name;\n    return this.parent != null && (this.parent.insertBefore(replacement, this.next || void 0), this.remove()), replacement;\n  }\n  split(index, _force) {\n    return index === 0 ? this : this.next;\n  }\n  update(_mutations, _context) {\n  }\n  wrap(name, value) {\n    const wrapper = typeof name == \"string\" ? this.scroll.create(name, value) : name;\n    if (this.parent != null && this.parent.insertBefore(wrapper, this.next || void 0), typeof wrapper.appendChild != \"function\")\n      throw new ParchmentError(`Cannot wrap ${name}`);\n    return wrapper.appendChild(this), wrapper;\n  }\n};\n_ShadowBlot.blotName = \"abstract\";\nlet ShadowBlot = _ShadowBlot;\nconst _LeafBlot = class _LeafBlot extends ShadowBlot {\n  /**\n   * Returns the value represented by domNode if it is this Blot's type\n   * No checking that domNode can represent this Blot type is required so\n   * applications needing it should check externally before calling.\n   */\n  static value(_domNode) {\n    return !0;\n  }\n  /**\n   * Given location represented by node and offset from DOM Selection Range,\n   * return index to that location.\n   */\n  index(node, offset) {\n    return this.domNode === node || this.domNode.compareDocumentPosition(node) & Node.DOCUMENT_POSITION_CONTAINED_BY ? Math.min(offset, 1) : -1;\n  }\n  /**\n   * Given index to location within blot, return node and offset representing\n   * that location, consumable by DOM Selection Range\n   */\n  position(index, _inclusive) {\n    let offset = Array.from(this.parent.domNode.childNodes).indexOf(this.domNode);\n    return index > 0 && (offset += 1), [this.parent.domNode, offset];\n  }\n  /**\n   * Return value represented by this blot\n   * Should not change without interaction from API or\n   * user change detectable by update()\n   */\n  value() {\n    return {\n      [this.statics.blotName]: this.statics.value(this.domNode) || !0\n    };\n  }\n};\n_LeafBlot.scope = Scope.INLINE_BLOT;\nlet LeafBlot = _LeafBlot;\nconst LeafBlot$1 = LeafBlot;\nclass LinkedList {\n  constructor() {\n    this.head = null, this.tail = null, this.length = 0;\n  }\n  append(...nodes) {\n    if (this.insertBefore(nodes[0], null), nodes.length > 1) {\n      const rest = nodes.slice(1);\n      this.append(...rest);\n    }\n  }\n  at(index) {\n    const next = this.iterator();\n    let cur = next();\n    for (; cur && index > 0; )\n      index -= 1, cur = next();\n    return cur;\n  }\n  contains(node) {\n    const next = this.iterator();\n    let cur = next();\n    for (; cur; ) {\n      if (cur === node)\n        return !0;\n      cur = next();\n    }\n    return !1;\n  }\n  indexOf(node) {\n    const next = this.iterator();\n    let cur = next(), index = 0;\n    for (; cur; ) {\n      if (cur === node)\n        return index;\n      index += 1, cur = next();\n    }\n    return -1;\n  }\n  insertBefore(node, refNode) {\n    node != null && (this.remove(node), node.next = refNode, refNode != null ? (node.prev = refNode.prev, refNode.prev != null && (refNode.prev.next = node), refNode.prev = node, refNode === this.head && (this.head = node)) : this.tail != null ? (this.tail.next = node, node.prev = this.tail, this.tail = node) : (node.prev = null, this.head = this.tail = node), this.length += 1);\n  }\n  offset(target) {\n    let index = 0, cur = this.head;\n    for (; cur != null; ) {\n      if (cur === target)\n        return index;\n      index += cur.length(), cur = cur.next;\n    }\n    return -1;\n  }\n  remove(node) {\n    this.contains(node) && (node.prev != null && (node.prev.next = node.next), node.next != null && (node.next.prev = node.prev), node === this.head && (this.head = node.next), node === this.tail && (this.tail = node.prev), this.length -= 1);\n  }\n  iterator(curNode = this.head) {\n    return () => {\n      const ret = curNode;\n      return curNode != null && (curNode = curNode.next), ret;\n    };\n  }\n  find(index, inclusive = !1) {\n    const next = this.iterator();\n    let cur = next();\n    for (; cur; ) {\n      const length = cur.length();\n      if (index < length || inclusive && index === length && (cur.next == null || cur.next.length() !== 0))\n        return [cur, index];\n      index -= length, cur = next();\n    }\n    return [null, 0];\n  }\n  forEach(callback) {\n    const next = this.iterator();\n    let cur = next();\n    for (; cur; )\n      callback(cur), cur = next();\n  }\n  forEachAt(index, length, callback) {\n    if (length <= 0)\n      return;\n    const [startNode, offset] = this.find(index);\n    let curIndex = index - offset;\n    const next = this.iterator(startNode);\n    let cur = next();\n    for (; cur && curIndex < index + length; ) {\n      const curLength = cur.length();\n      index > curIndex ? callback(\n        cur,\n        index - curIndex,\n        Math.min(length, curIndex + curLength - index)\n      ) : callback(cur, 0, Math.min(curLength, index + length - curIndex)), curIndex += curLength, cur = next();\n    }\n  }\n  map(callback) {\n    return this.reduce((memo, cur) => (memo.push(callback(cur)), memo), []);\n  }\n  reduce(callback, memo) {\n    const next = this.iterator();\n    let cur = next();\n    for (; cur; )\n      memo = callback(memo, cur), cur = next();\n    return memo;\n  }\n}\nfunction makeAttachedBlot(node, scroll) {\n  const found = scroll.find(node);\n  if (found)\n    return found;\n  try {\n    return scroll.create(node);\n  } catch {\n    const blot = scroll.create(Scope.INLINE);\n    return Array.from(node.childNodes).forEach((child) => {\n      blot.domNode.appendChild(child);\n    }), node.parentNode && node.parentNode.replaceChild(blot.domNode, node), blot.attach(), blot;\n  }\n}\nconst _ParentBlot = class _ParentBlot extends ShadowBlot {\n  constructor(scroll, domNode) {\n    super(scroll, domNode), this.uiNode = null, this.build();\n  }\n  appendChild(other) {\n    this.insertBefore(other);\n  }\n  attach() {\n    super.attach(), this.children.forEach((child) => {\n      child.attach();\n    });\n  }\n  attachUI(node) {\n    this.uiNode != null && this.uiNode.remove(), this.uiNode = node, _ParentBlot.uiClass && this.uiNode.classList.add(_ParentBlot.uiClass), this.uiNode.setAttribute(\"contenteditable\", \"false\"), this.domNode.insertBefore(this.uiNode, this.domNode.firstChild);\n  }\n  /**\n   * Called during construction, should fill its own children LinkedList.\n   */\n  build() {\n    this.children = new LinkedList(), Array.from(this.domNode.childNodes).filter((node) => node !== this.uiNode).reverse().forEach((node) => {\n      try {\n        const child = makeAttachedBlot(node, this.scroll);\n        this.insertBefore(child, this.children.head || void 0);\n      } catch (err) {\n        if (err instanceof ParchmentError)\n          return;\n        throw err;\n      }\n    });\n  }\n  deleteAt(index, length) {\n    if (index === 0 && length === this.length())\n      return this.remove();\n    this.children.forEachAt(index, length, (child, offset, childLength) => {\n      child.deleteAt(offset, childLength);\n    });\n  }\n  descendant(criteria, index = 0) {\n    const [child, offset] = this.children.find(index);\n    return criteria.blotName == null && criteria(child) || criteria.blotName != null && child instanceof criteria ? [child, offset] : child instanceof _ParentBlot ? child.descendant(criteria, offset) : [null, -1];\n  }\n  descendants(criteria, index = 0, length = Number.MAX_VALUE) {\n    let descendants = [], lengthLeft = length;\n    return this.children.forEachAt(\n      index,\n      length,\n      (child, childIndex, childLength) => {\n        (criteria.blotName == null && criteria(child) || criteria.blotName != null && child instanceof criteria) && descendants.push(child), child instanceof _ParentBlot && (descendants = descendants.concat(\n          child.descendants(criteria, childIndex, lengthLeft)\n        )), lengthLeft -= childLength;\n      }\n    ), descendants;\n  }\n  detach() {\n    this.children.forEach((child) => {\n      child.detach();\n    }), super.detach();\n  }\n  enforceAllowedChildren() {\n    let done = !1;\n    this.children.forEach((child) => {\n      done || this.statics.allowedChildren.some(\n        (def) => child instanceof def\n      ) || (child.statics.scope === Scope.BLOCK_BLOT ? (child.next != null && this.splitAfter(child), child.prev != null && this.splitAfter(child.prev), child.parent.unwrap(), done = !0) : child instanceof _ParentBlot ? child.unwrap() : child.remove());\n    });\n  }\n  formatAt(index, length, name, value) {\n    this.children.forEachAt(index, length, (child, offset, childLength) => {\n      child.formatAt(offset, childLength, name, value);\n    });\n  }\n  insertAt(index, value, def) {\n    const [child, offset] = this.children.find(index);\n    if (child)\n      child.insertAt(offset, value, def);\n    else {\n      const blot = def == null ? this.scroll.create(\"text\", value) : this.scroll.create(value, def);\n      this.appendChild(blot);\n    }\n  }\n  insertBefore(childBlot, refBlot) {\n    childBlot.parent != null && childBlot.parent.children.remove(childBlot);\n    let refDomNode = null;\n    this.children.insertBefore(childBlot, refBlot || null), childBlot.parent = this, refBlot != null && (refDomNode = refBlot.domNode), (this.domNode.parentNode !== childBlot.domNode || this.domNode.nextSibling !== refDomNode) && this.domNode.insertBefore(childBlot.domNode, refDomNode), childBlot.attach();\n  }\n  length() {\n    return this.children.reduce((memo, child) => memo + child.length(), 0);\n  }\n  moveChildren(targetParent, refNode) {\n    this.children.forEach((child) => {\n      targetParent.insertBefore(child, refNode);\n    });\n  }\n  optimize(context) {\n    if (super.optimize(context), this.enforceAllowedChildren(), this.uiNode != null && this.uiNode !== this.domNode.firstChild && this.domNode.insertBefore(this.uiNode, this.domNode.firstChild), this.children.length === 0)\n      if (this.statics.defaultChild != null) {\n        const child = this.scroll.create(this.statics.defaultChild.blotName);\n        this.appendChild(child);\n      } else\n        this.remove();\n  }\n  path(index, inclusive = !1) {\n    const [child, offset] = this.children.find(index, inclusive), position = [[this, index]];\n    return child instanceof _ParentBlot ? position.concat(child.path(offset, inclusive)) : (child != null && position.push([child, offset]), position);\n  }\n  removeChild(child) {\n    this.children.remove(child);\n  }\n  replaceWith(name, value) {\n    const replacement = typeof name == \"string\" ? this.scroll.create(name, value) : name;\n    return replacement instanceof _ParentBlot && this.moveChildren(replacement), super.replaceWith(replacement);\n  }\n  split(index, force = !1) {\n    if (!force) {\n      if (index === 0)\n        return this;\n      if (index === this.length())\n        return this.next;\n    }\n    const after = this.clone();\n    return this.parent && this.parent.insertBefore(after, this.next || void 0), this.children.forEachAt(index, this.length(), (child, offset, _length) => {\n      const split = child.split(offset, force);\n      split != null && after.appendChild(split);\n    }), after;\n  }\n  splitAfter(child) {\n    const after = this.clone();\n    for (; child.next != null; )\n      after.appendChild(child.next);\n    return this.parent && this.parent.insertBefore(after, this.next || void 0), after;\n  }\n  unwrap() {\n    this.parent && this.moveChildren(this.parent, this.next || void 0), this.remove();\n  }\n  update(mutations, _context) {\n    const addedNodes = [], removedNodes = [];\n    mutations.forEach((mutation) => {\n      mutation.target === this.domNode && mutation.type === \"childList\" && (addedNodes.push(...mutation.addedNodes), removedNodes.push(...mutation.removedNodes));\n    }), removedNodes.forEach((node) => {\n      if (node.parentNode != null && // @ts-expect-error Fix me later\n      node.tagName !== \"IFRAME\" && document.body.compareDocumentPosition(node) & Node.DOCUMENT_POSITION_CONTAINED_BY)\n        return;\n      const blot = this.scroll.find(node);\n      blot != null && (blot.domNode.parentNode == null || blot.domNode.parentNode === this.domNode) && blot.detach();\n    }), addedNodes.filter((node) => node.parentNode === this.domNode && node !== this.uiNode).sort((a, b) => a === b ? 0 : a.compareDocumentPosition(b) & Node.DOCUMENT_POSITION_FOLLOWING ? 1 : -1).forEach((node) => {\n      let refBlot = null;\n      node.nextSibling != null && (refBlot = this.scroll.find(node.nextSibling));\n      const blot = makeAttachedBlot(node, this.scroll);\n      (blot.next !== refBlot || blot.next == null) && (blot.parent != null && blot.parent.removeChild(this), this.insertBefore(blot, refBlot || void 0));\n    }), this.enforceAllowedChildren();\n  }\n};\n_ParentBlot.uiClass = \"\";\nlet ParentBlot = _ParentBlot;\nconst ParentBlot$1 = ParentBlot;\nfunction isEqual(obj1, obj2) {\n  if (Object.keys(obj1).length !== Object.keys(obj2).length)\n    return !1;\n  for (const prop in obj1)\n    if (obj1[prop] !== obj2[prop])\n      return !1;\n  return !0;\n}\nconst _InlineBlot = class _InlineBlot extends ParentBlot$1 {\n  static create(value) {\n    return super.create(value);\n  }\n  static formats(domNode, scroll) {\n    const match2 = scroll.query(_InlineBlot.blotName);\n    if (!(match2 != null && domNode.tagName === match2.tagName)) {\n      if (typeof this.tagName == \"string\")\n        return !0;\n      if (Array.isArray(this.tagName))\n        return domNode.tagName.toLowerCase();\n    }\n  }\n  constructor(scroll, domNode) {\n    super(scroll, domNode), this.attributes = new AttributorStore$1(this.domNode);\n  }\n  format(name, value) {\n    if (name === this.statics.blotName && !value)\n      this.children.forEach((child) => {\n        child instanceof _InlineBlot || (child = child.wrap(_InlineBlot.blotName, !0)), this.attributes.copy(child);\n      }), this.unwrap();\n    else {\n      const format = this.scroll.query(name, Scope.INLINE);\n      if (format == null)\n        return;\n      format instanceof Attributor ? this.attributes.attribute(format, value) : value && (name !== this.statics.blotName || this.formats()[name] !== value) && this.replaceWith(name, value);\n    }\n  }\n  formats() {\n    const formats = this.attributes.values(), format = this.statics.formats(this.domNode, this.scroll);\n    return format != null && (formats[this.statics.blotName] = format), formats;\n  }\n  formatAt(index, length, name, value) {\n    this.formats()[name] != null || this.scroll.query(name, Scope.ATTRIBUTE) ? this.isolate(index, length).format(name, value) : super.formatAt(index, length, name, value);\n  }\n  optimize(context) {\n    super.optimize(context);\n    const formats = this.formats();\n    if (Object.keys(formats).length === 0)\n      return this.unwrap();\n    const next = this.next;\n    next instanceof _InlineBlot && next.prev === this && isEqual(formats, next.formats()) && (next.moveChildren(this), next.remove());\n  }\n  replaceWith(name, value) {\n    const replacement = super.replaceWith(name, value);\n    return this.attributes.copy(replacement), replacement;\n  }\n  update(mutations, context) {\n    super.update(mutations, context), mutations.some(\n      (mutation) => mutation.target === this.domNode && mutation.type === \"attributes\"\n    ) && this.attributes.build();\n  }\n  wrap(name, value) {\n    const wrapper = super.wrap(name, value);\n    return wrapper instanceof _InlineBlot && this.attributes.move(wrapper), wrapper;\n  }\n};\n_InlineBlot.allowedChildren = [_InlineBlot, LeafBlot$1], _InlineBlot.blotName = \"inline\", _InlineBlot.scope = Scope.INLINE_BLOT, _InlineBlot.tagName = \"SPAN\";\nlet InlineBlot = _InlineBlot;\nconst InlineBlot$1 = InlineBlot, _BlockBlot = class _BlockBlot extends ParentBlot$1 {\n  static create(value) {\n    return super.create(value);\n  }\n  static formats(domNode, scroll) {\n    const match2 = scroll.query(_BlockBlot.blotName);\n    if (!(match2 != null && domNode.tagName === match2.tagName)) {\n      if (typeof this.tagName == \"string\")\n        return !0;\n      if (Array.isArray(this.tagName))\n        return domNode.tagName.toLowerCase();\n    }\n  }\n  constructor(scroll, domNode) {\n    super(scroll, domNode), this.attributes = new AttributorStore$1(this.domNode);\n  }\n  format(name, value) {\n    const format = this.scroll.query(name, Scope.BLOCK);\n    format != null && (format instanceof Attributor ? this.attributes.attribute(format, value) : name === this.statics.blotName && !value ? this.replaceWith(_BlockBlot.blotName) : value && (name !== this.statics.blotName || this.formats()[name] !== value) && this.replaceWith(name, value));\n  }\n  formats() {\n    const formats = this.attributes.values(), format = this.statics.formats(this.domNode, this.scroll);\n    return format != null && (formats[this.statics.blotName] = format), formats;\n  }\n  formatAt(index, length, name, value) {\n    this.scroll.query(name, Scope.BLOCK) != null ? this.format(name, value) : super.formatAt(index, length, name, value);\n  }\n  insertAt(index, value, def) {\n    if (def == null || this.scroll.query(value, Scope.INLINE) != null)\n      super.insertAt(index, value, def);\n    else {\n      const after = this.split(index);\n      if (after != null) {\n        const blot = this.scroll.create(value, def);\n        after.parent.insertBefore(blot, after);\n      } else\n        throw new Error(\"Attempt to insertAt after block boundaries\");\n    }\n  }\n  replaceWith(name, value) {\n    const replacement = super.replaceWith(name, value);\n    return this.attributes.copy(replacement), replacement;\n  }\n  update(mutations, context) {\n    super.update(mutations, context), mutations.some(\n      (mutation) => mutation.target === this.domNode && mutation.type === \"attributes\"\n    ) && this.attributes.build();\n  }\n};\n_BlockBlot.blotName = \"block\", _BlockBlot.scope = Scope.BLOCK_BLOT, _BlockBlot.tagName = \"P\", _BlockBlot.allowedChildren = [\n  InlineBlot$1,\n  _BlockBlot,\n  LeafBlot$1\n];\nlet BlockBlot = _BlockBlot;\nconst BlockBlot$1 = BlockBlot, _ContainerBlot = class _ContainerBlot extends ParentBlot$1 {\n  checkMerge() {\n    return this.next !== null && this.next.statics.blotName === this.statics.blotName;\n  }\n  deleteAt(index, length) {\n    super.deleteAt(index, length), this.enforceAllowedChildren();\n  }\n  formatAt(index, length, name, value) {\n    super.formatAt(index, length, name, value), this.enforceAllowedChildren();\n  }\n  insertAt(index, value, def) {\n    super.insertAt(index, value, def), this.enforceAllowedChildren();\n  }\n  optimize(context) {\n    super.optimize(context), this.children.length > 0 && this.next != null && this.checkMerge() && (this.next.moveChildren(this), this.next.remove());\n  }\n};\n_ContainerBlot.blotName = \"container\", _ContainerBlot.scope = Scope.BLOCK_BLOT;\nlet ContainerBlot = _ContainerBlot;\nconst ContainerBlot$1 = ContainerBlot;\nclass EmbedBlot extends LeafBlot$1 {\n  static formats(_domNode, _scroll) {\n  }\n  format(name, value) {\n    super.formatAt(0, this.length(), name, value);\n  }\n  formatAt(index, length, name, value) {\n    index === 0 && length === this.length() ? this.format(name, value) : super.formatAt(index, length, name, value);\n  }\n  formats() {\n    return this.statics.formats(this.domNode, this.scroll);\n  }\n}\nconst EmbedBlot$1 = EmbedBlot, OBSERVER_CONFIG = {\n  attributes: !0,\n  characterData: !0,\n  characterDataOldValue: !0,\n  childList: !0,\n  subtree: !0\n}, MAX_OPTIMIZE_ITERATIONS = 100, _ScrollBlot = class _ScrollBlot extends ParentBlot$1 {\n  constructor(registry, node) {\n    super(null, node), this.registry = registry, this.scroll = this, this.build(), this.observer = new MutationObserver((mutations) => {\n      this.update(mutations);\n    }), this.observer.observe(this.domNode, OBSERVER_CONFIG), this.attach();\n  }\n  create(input, value) {\n    return this.registry.create(this, input, value);\n  }\n  find(node, bubble = !1) {\n    const blot = this.registry.find(node, bubble);\n    return blot ? blot.scroll === this ? blot : bubble ? this.find(blot.scroll.domNode.parentNode, !0) : null : null;\n  }\n  query(query, scope = Scope.ANY) {\n    return this.registry.query(query, scope);\n  }\n  register(...definitions) {\n    return this.registry.register(...definitions);\n  }\n  build() {\n    this.scroll != null && super.build();\n  }\n  detach() {\n    super.detach(), this.observer.disconnect();\n  }\n  deleteAt(index, length) {\n    this.update(), index === 0 && length === this.length() ? this.children.forEach((child) => {\n      child.remove();\n    }) : super.deleteAt(index, length);\n  }\n  formatAt(index, length, name, value) {\n    this.update(), super.formatAt(index, length, name, value);\n  }\n  insertAt(index, value, def) {\n    this.update(), super.insertAt(index, value, def);\n  }\n  optimize(mutations = [], context = {}) {\n    super.optimize(context);\n    const mutationsMap = context.mutationsMap || /* @__PURE__ */ new WeakMap();\n    let records = Array.from(this.observer.takeRecords());\n    for (; records.length > 0; )\n      mutations.push(records.pop());\n    const mark = (blot, markParent = !0) => {\n      blot == null || blot === this || blot.domNode.parentNode != null && (mutationsMap.has(blot.domNode) || mutationsMap.set(blot.domNode, []), markParent && mark(blot.parent));\n    }, optimize = (blot) => {\n      mutationsMap.has(blot.domNode) && (blot instanceof ParentBlot$1 && blot.children.forEach(optimize), mutationsMap.delete(blot.domNode), blot.optimize(context));\n    };\n    let remaining = mutations;\n    for (let i = 0; remaining.length > 0; i += 1) {\n      if (i >= MAX_OPTIMIZE_ITERATIONS)\n        throw new Error(\"[Parchment] Maximum optimize iterations reached\");\n      for (remaining.forEach((mutation) => {\n        const blot = this.find(mutation.target, !0);\n        blot != null && (blot.domNode === mutation.target && (mutation.type === \"childList\" ? (mark(this.find(mutation.previousSibling, !1)), Array.from(mutation.addedNodes).forEach((node) => {\n          const child = this.find(node, !1);\n          mark(child, !1), child instanceof ParentBlot$1 && child.children.forEach((grandChild) => {\n            mark(grandChild, !1);\n          });\n        })) : mutation.type === \"attributes\" && mark(blot.prev)), mark(blot));\n      }), this.children.forEach(optimize), remaining = Array.from(this.observer.takeRecords()), records = remaining.slice(); records.length > 0; )\n        mutations.push(records.pop());\n    }\n  }\n  update(mutations, context = {}) {\n    mutations = mutations || this.observer.takeRecords();\n    const mutationsMap = /* @__PURE__ */ new WeakMap();\n    mutations.map((mutation) => {\n      const blot = this.find(mutation.target, !0);\n      return blot == null ? null : mutationsMap.has(blot.domNode) ? (mutationsMap.get(blot.domNode).push(mutation), null) : (mutationsMap.set(blot.domNode, [mutation]), blot);\n    }).forEach((blot) => {\n      blot != null && blot !== this && mutationsMap.has(blot.domNode) && blot.update(mutationsMap.get(blot.domNode) || [], context);\n    }), context.mutationsMap = mutationsMap, mutationsMap.has(this.domNode) && super.update(mutationsMap.get(this.domNode), context), this.optimize(mutations, context);\n  }\n};\n_ScrollBlot.blotName = \"scroll\", _ScrollBlot.defaultChild = BlockBlot$1, _ScrollBlot.allowedChildren = [BlockBlot$1, ContainerBlot$1], _ScrollBlot.scope = Scope.BLOCK_BLOT, _ScrollBlot.tagName = \"DIV\";\nlet ScrollBlot = _ScrollBlot;\nconst ScrollBlot$1 = ScrollBlot, _TextBlot = class _TextBlot extends LeafBlot$1 {\n  static create(value) {\n    return document.createTextNode(value);\n  }\n  static value(domNode) {\n    return domNode.data;\n  }\n  constructor(scroll, node) {\n    super(scroll, node), this.text = this.statics.value(this.domNode);\n  }\n  deleteAt(index, length) {\n    this.domNode.data = this.text = this.text.slice(0, index) + this.text.slice(index + length);\n  }\n  index(node, offset) {\n    return this.domNode === node ? offset : -1;\n  }\n  insertAt(index, value, def) {\n    def == null ? (this.text = this.text.slice(0, index) + value + this.text.slice(index), this.domNode.data = this.text) : super.insertAt(index, value, def);\n  }\n  length() {\n    return this.text.length;\n  }\n  optimize(context) {\n    super.optimize(context), this.text = this.statics.value(this.domNode), this.text.length === 0 ? this.remove() : this.next instanceof _TextBlot && this.next.prev === this && (this.insertAt(this.length(), this.next.value()), this.next.remove());\n  }\n  position(index, _inclusive = !1) {\n    return [this.domNode, index];\n  }\n  split(index, force = !1) {\n    if (!force) {\n      if (index === 0)\n        return this;\n      if (index === this.length())\n        return this.next;\n    }\n    const after = this.scroll.create(this.domNode.splitText(index));\n    return this.parent.insertBefore(after, this.next || void 0), this.text = this.statics.value(this.domNode), after;\n  }\n  update(mutations, _context) {\n    mutations.some((mutation) => mutation.type === \"characterData\" && mutation.target === this.domNode) && (this.text = this.statics.value(this.domNode));\n  }\n  value() {\n    return this.text;\n  }\n};\n_TextBlot.blotName = \"text\", _TextBlot.scope = Scope.INLINE_BLOT;\nlet TextBlot = _TextBlot;\nconst TextBlot$1 = TextBlot;\n\n//# sourceMappingURL=parchment.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcGFyY2htZW50L2Rpc3QvcGFyY2htZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsa2hCQUFraEI7QUFDbGhCO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQixnQkFBZ0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELE9BQU87QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBGQUEwRixPQUFPO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRixhQUFhLEdBQUcsTUFBTTtBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLEtBQUs7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsa0JBQWtCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrQ0FBa0M7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxXQUFXLG9CQUFvQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQSxXQUFXLG9CQUFvQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCxPQUFPLHNIQUFzSCxvQkFBb0I7QUFDako7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFnQkU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2RvY2Fzc2lzdC8uL25vZGVfbW9kdWxlcy9wYXJjaG1lbnQvZGlzdC9wYXJjaG1lbnQuanM/ZDJmZSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgU2NvcGUgPSAvKiBAX19QVVJFX18gKi8gKChTY29wZTIpID0+IChTY29wZTJbU2NvcGUyLlRZUEUgPSAzXSA9IFwiVFlQRVwiLCBTY29wZTJbU2NvcGUyLkxFVkVMID0gMTJdID0gXCJMRVZFTFwiLCBTY29wZTJbU2NvcGUyLkFUVFJJQlVURSA9IDEzXSA9IFwiQVRUUklCVVRFXCIsIFNjb3BlMltTY29wZTIuQkxPVCA9IDE0XSA9IFwiQkxPVFwiLCBTY29wZTJbU2NvcGUyLklOTElORSA9IDddID0gXCJJTkxJTkVcIiwgU2NvcGUyW1Njb3BlMi5CTE9DSyA9IDExXSA9IFwiQkxPQ0tcIiwgU2NvcGUyW1Njb3BlMi5CTE9DS19CTE9UID0gMTBdID0gXCJCTE9DS19CTE9UXCIsIFNjb3BlMltTY29wZTIuSU5MSU5FX0JMT1QgPSA2XSA9IFwiSU5MSU5FX0JMT1RcIiwgU2NvcGUyW1Njb3BlMi5CTE9DS19BVFRSSUJVVEUgPSA5XSA9IFwiQkxPQ0tfQVRUUklCVVRFXCIsIFNjb3BlMltTY29wZTIuSU5MSU5FX0FUVFJJQlVURSA9IDVdID0gXCJJTkxJTkVfQVRUUklCVVRFXCIsIFNjb3BlMltTY29wZTIuQU5ZID0gMTVdID0gXCJBTllcIiwgU2NvcGUyKSkoU2NvcGUgfHwge30pO1xuY2xhc3MgQXR0cmlidXRvciB7XG4gIGNvbnN0cnVjdG9yKGF0dHJOYW1lLCBrZXlOYW1lLCBvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLmF0dHJOYW1lID0gYXR0ck5hbWUsIHRoaXMua2V5TmFtZSA9IGtleU5hbWU7XG4gICAgY29uc3QgYXR0cmlidXRlQml0ID0gU2NvcGUuVFlQRSAmIFNjb3BlLkFUVFJJQlVURTtcbiAgICB0aGlzLnNjb3BlID0gb3B0aW9ucy5zY29wZSAhPSBudWxsID8gKFxuICAgICAgLy8gSWdub3JlIHR5cGUgYml0cywgZm9yY2UgYXR0cmlidXRlIGJpdFxuICAgICAgb3B0aW9ucy5zY29wZSAmIFNjb3BlLkxFVkVMIHwgYXR0cmlidXRlQml0XG4gICAgKSA6IFNjb3BlLkFUVFJJQlVURSwgb3B0aW9ucy53aGl0ZWxpc3QgIT0gbnVsbCAmJiAodGhpcy53aGl0ZWxpc3QgPSBvcHRpb25zLndoaXRlbGlzdCk7XG4gIH1cbiAgc3RhdGljIGtleXMobm9kZSkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKG5vZGUuYXR0cmlidXRlcykubWFwKChpdGVtKSA9PiBpdGVtLm5hbWUpO1xuICB9XG4gIGFkZChub2RlLCB2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmNhbkFkZChub2RlLCB2YWx1ZSkgPyAobm9kZS5zZXRBdHRyaWJ1dGUodGhpcy5rZXlOYW1lLCB2YWx1ZSksICEwKSA6ICExO1xuICB9XG4gIGNhbkFkZChfbm9kZSwgdmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy53aGl0ZWxpc3QgPT0gbnVsbCA/ICEwIDogdHlwZW9mIHZhbHVlID09IFwic3RyaW5nXCIgPyB0aGlzLndoaXRlbGlzdC5pbmRleE9mKHZhbHVlLnJlcGxhY2UoL1tcIiddL2csIFwiXCIpKSA+IC0xIDogdGhpcy53aGl0ZWxpc3QuaW5kZXhPZih2YWx1ZSkgPiAtMTtcbiAgfVxuICByZW1vdmUobm9kZSkge1xuICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKHRoaXMua2V5TmFtZSk7XG4gIH1cbiAgdmFsdWUobm9kZSkge1xuICAgIGNvbnN0IHZhbHVlID0gbm9kZS5nZXRBdHRyaWJ1dGUodGhpcy5rZXlOYW1lKTtcbiAgICByZXR1cm4gdGhpcy5jYW5BZGQobm9kZSwgdmFsdWUpICYmIHZhbHVlID8gdmFsdWUgOiBcIlwiO1xuICB9XG59XG5jbGFzcyBQYXJjaG1lbnRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgIG1lc3NhZ2UgPSBcIltQYXJjaG1lbnRdIFwiICsgbWVzc2FnZSwgc3VwZXIobWVzc2FnZSksIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UsIHRoaXMubmFtZSA9IHRoaXMuY29uc3RydWN0b3IubmFtZTtcbiAgfVxufVxuY29uc3QgX1JlZ2lzdHJ5ID0gY2xhc3MgX1JlZ2lzdHJ5IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5hdHRyaWJ1dGVzID0ge30sIHRoaXMuY2xhc3NlcyA9IHt9LCB0aGlzLnRhZ3MgPSB7fSwgdGhpcy50eXBlcyA9IHt9O1xuICB9XG4gIHN0YXRpYyBmaW5kKG5vZGUsIGJ1YmJsZSA9ICExKSB7XG4gICAgaWYgKG5vZGUgPT0gbnVsbClcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGlmICh0aGlzLmJsb3RzLmhhcyhub2RlKSlcbiAgICAgIHJldHVybiB0aGlzLmJsb3RzLmdldChub2RlKSB8fCBudWxsO1xuICAgIGlmIChidWJibGUpIHtcbiAgICAgIGxldCBwYXJlbnROb2RlID0gbnVsbDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHBhcmVudE5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5maW5kKHBhcmVudE5vZGUsIGJ1YmJsZSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNyZWF0ZShzY3JvbGwsIGlucHV0LCB2YWx1ZSkge1xuICAgIGNvbnN0IG1hdGNoMiA9IHRoaXMucXVlcnkoaW5wdXQpO1xuICAgIGlmIChtYXRjaDIgPT0gbnVsbClcbiAgICAgIHRocm93IG5ldyBQYXJjaG1lbnRFcnJvcihgVW5hYmxlIHRvIGNyZWF0ZSAke2lucHV0fSBibG90YCk7XG4gICAgY29uc3QgYmxvdENsYXNzID0gbWF0Y2gyLCBub2RlID0gKFxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBGaXggbWUgbGF0ZXJcbiAgICAgIGlucHV0IGluc3RhbmNlb2YgTm9kZSB8fCBpbnB1dC5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUgPyBpbnB1dCA6IGJsb3RDbGFzcy5jcmVhdGUodmFsdWUpXG4gICAgKSwgYmxvdCA9IG5ldyBibG90Q2xhc3Moc2Nyb2xsLCBub2RlLCB2YWx1ZSk7XG4gICAgcmV0dXJuIF9SZWdpc3RyeS5ibG90cy5zZXQoYmxvdC5kb21Ob2RlLCBibG90KSwgYmxvdDtcbiAgfVxuICBmaW5kKG5vZGUsIGJ1YmJsZSA9ICExKSB7XG4gICAgcmV0dXJuIF9SZWdpc3RyeS5maW5kKG5vZGUsIGJ1YmJsZSk7XG4gIH1cbiAgcXVlcnkocXVlcnksIHNjb3BlID0gU2NvcGUuQU5ZKSB7XG4gICAgbGV0IG1hdGNoMjtcbiAgICByZXR1cm4gdHlwZW9mIHF1ZXJ5ID09IFwic3RyaW5nXCIgPyBtYXRjaDIgPSB0aGlzLnR5cGVzW3F1ZXJ5XSB8fCB0aGlzLmF0dHJpYnV0ZXNbcXVlcnldIDogcXVlcnkgaW5zdGFuY2VvZiBUZXh0IHx8IHF1ZXJ5Lm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSA/IG1hdGNoMiA9IHRoaXMudHlwZXMudGV4dCA6IHR5cGVvZiBxdWVyeSA9PSBcIm51bWJlclwiID8gcXVlcnkgJiBTY29wZS5MRVZFTCAmIFNjb3BlLkJMT0NLID8gbWF0Y2gyID0gdGhpcy50eXBlcy5ibG9jayA6IHF1ZXJ5ICYgU2NvcGUuTEVWRUwgJiBTY29wZS5JTkxJTkUgJiYgKG1hdGNoMiA9IHRoaXMudHlwZXMuaW5saW5lKSA6IHF1ZXJ5IGluc3RhbmNlb2YgRWxlbWVudCAmJiAoKHF1ZXJ5LmdldEF0dHJpYnV0ZShcImNsYXNzXCIpIHx8IFwiXCIpLnNwbGl0KC9cXHMrLykuc29tZSgobmFtZSkgPT4gKG1hdGNoMiA9IHRoaXMuY2xhc3Nlc1tuYW1lXSwgISFtYXRjaDIpKSwgbWF0Y2gyID0gbWF0Y2gyIHx8IHRoaXMudGFnc1txdWVyeS50YWdOYW1lXSksIG1hdGNoMiA9PSBudWxsID8gbnVsbCA6IFwic2NvcGVcIiBpbiBtYXRjaDIgJiYgc2NvcGUgJiBTY29wZS5MRVZFTCAmIG1hdGNoMi5zY29wZSAmJiBzY29wZSAmIFNjb3BlLlRZUEUgJiBtYXRjaDIuc2NvcGUgPyBtYXRjaDIgOiBudWxsO1xuICB9XG4gIHJlZ2lzdGVyKC4uLmRlZmluaXRpb25zKSB7XG4gICAgcmV0dXJuIGRlZmluaXRpb25zLm1hcCgoZGVmaW5pdGlvbikgPT4ge1xuICAgICAgY29uc3QgaXNCbG90ID0gXCJibG90TmFtZVwiIGluIGRlZmluaXRpb24sIGlzQXR0ciA9IFwiYXR0ck5hbWVcIiBpbiBkZWZpbml0aW9uO1xuICAgICAgaWYgKCFpc0Jsb3QgJiYgIWlzQXR0cilcbiAgICAgICAgdGhyb3cgbmV3IFBhcmNobWVudEVycm9yKFwiSW52YWxpZCBkZWZpbml0aW9uXCIpO1xuICAgICAgaWYgKGlzQmxvdCAmJiBkZWZpbml0aW9uLmJsb3ROYW1lID09PSBcImFic3RyYWN0XCIpXG4gICAgICAgIHRocm93IG5ldyBQYXJjaG1lbnRFcnJvcihcIkNhbm5vdCByZWdpc3RlciBhYnN0cmFjdCBjbGFzc1wiKTtcbiAgICAgIGNvbnN0IGtleSA9IGlzQmxvdCA/IGRlZmluaXRpb24uYmxvdE5hbWUgOiBpc0F0dHIgPyBkZWZpbml0aW9uLmF0dHJOYW1lIDogdm9pZCAwO1xuICAgICAgcmV0dXJuIHRoaXMudHlwZXNba2V5XSA9IGRlZmluaXRpb24sIGlzQXR0ciA/IHR5cGVvZiBkZWZpbml0aW9uLmtleU5hbWUgPT0gXCJzdHJpbmdcIiAmJiAodGhpcy5hdHRyaWJ1dGVzW2RlZmluaXRpb24ua2V5TmFtZV0gPSBkZWZpbml0aW9uKSA6IGlzQmxvdCAmJiAoZGVmaW5pdGlvbi5jbGFzc05hbWUgJiYgKHRoaXMuY2xhc3Nlc1tkZWZpbml0aW9uLmNsYXNzTmFtZV0gPSBkZWZpbml0aW9uKSwgZGVmaW5pdGlvbi50YWdOYW1lICYmIChBcnJheS5pc0FycmF5KGRlZmluaXRpb24udGFnTmFtZSkgPyBkZWZpbml0aW9uLnRhZ05hbWUgPSBkZWZpbml0aW9uLnRhZ05hbWUubWFwKCh0YWdOYW1lKSA9PiB0YWdOYW1lLnRvVXBwZXJDYXNlKCkpIDogZGVmaW5pdGlvbi50YWdOYW1lID0gZGVmaW5pdGlvbi50YWdOYW1lLnRvVXBwZXJDYXNlKCksIChBcnJheS5pc0FycmF5KGRlZmluaXRpb24udGFnTmFtZSkgPyBkZWZpbml0aW9uLnRhZ05hbWUgOiBbZGVmaW5pdGlvbi50YWdOYW1lXSkuZm9yRWFjaCgodGFnKSA9PiB7XG4gICAgICAgICh0aGlzLnRhZ3NbdGFnXSA9PSBudWxsIHx8IGRlZmluaXRpb24uY2xhc3NOYW1lID09IG51bGwpICYmICh0aGlzLnRhZ3NbdGFnXSA9IGRlZmluaXRpb24pO1xuICAgICAgfSkpKSwgZGVmaW5pdGlvbjtcbiAgICB9KTtcbiAgfVxufTtcbl9SZWdpc3RyeS5ibG90cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xubGV0IFJlZ2lzdHJ5ID0gX1JlZ2lzdHJ5O1xuZnVuY3Rpb24gbWF0Y2gobm9kZSwgcHJlZml4KSB7XG4gIHJldHVybiAobm9kZS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSB8fCBcIlwiKS5zcGxpdCgvXFxzKy8pLmZpbHRlcigobmFtZSkgPT4gbmFtZS5pbmRleE9mKGAke3ByZWZpeH0tYCkgPT09IDApO1xufVxuY2xhc3MgQ2xhc3NBdHRyaWJ1dG9yIGV4dGVuZHMgQXR0cmlidXRvciB7XG4gIHN0YXRpYyBrZXlzKG5vZGUpIHtcbiAgICByZXR1cm4gKG5vZGUuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgfHwgXCJcIikuc3BsaXQoL1xccysvKS5tYXAoKG5hbWUpID0+IG5hbWUuc3BsaXQoXCItXCIpLnNsaWNlKDAsIC0xKS5qb2luKFwiLVwiKSk7XG4gIH1cbiAgYWRkKG5vZGUsIHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FuQWRkKG5vZGUsIHZhbHVlKSA/ICh0aGlzLnJlbW92ZShub2RlKSwgbm9kZS5jbGFzc0xpc3QuYWRkKGAke3RoaXMua2V5TmFtZX0tJHt2YWx1ZX1gKSwgITApIDogITE7XG4gIH1cbiAgcmVtb3ZlKG5vZGUpIHtcbiAgICBtYXRjaChub2RlLCB0aGlzLmtleU5hbWUpLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgIG5vZGUuY2xhc3NMaXN0LnJlbW92ZShuYW1lKTtcbiAgICB9KSwgbm9kZS5jbGFzc0xpc3QubGVuZ3RoID09PSAwICYmIG5vZGUucmVtb3ZlQXR0cmlidXRlKFwiY2xhc3NcIik7XG4gIH1cbiAgdmFsdWUobm9kZSkge1xuICAgIGNvbnN0IHZhbHVlID0gKG1hdGNoKG5vZGUsIHRoaXMua2V5TmFtZSlbMF0gfHwgXCJcIikuc2xpY2UodGhpcy5rZXlOYW1lLmxlbmd0aCArIDEpO1xuICAgIHJldHVybiB0aGlzLmNhbkFkZChub2RlLCB2YWx1ZSkgPyB2YWx1ZSA6IFwiXCI7XG4gIH1cbn1cbmNvbnN0IENsYXNzQXR0cmlidXRvciQxID0gQ2xhc3NBdHRyaWJ1dG9yO1xuZnVuY3Rpb24gY2FtZWxpemUobmFtZSkge1xuICBjb25zdCBwYXJ0cyA9IG5hbWUuc3BsaXQoXCItXCIpLCByZXN0ID0gcGFydHMuc2xpY2UoMSkubWFwKChwYXJ0KSA9PiBwYXJ0WzBdLnRvVXBwZXJDYXNlKCkgKyBwYXJ0LnNsaWNlKDEpKS5qb2luKFwiXCIpO1xuICByZXR1cm4gcGFydHNbMF0gKyByZXN0O1xufVxuY2xhc3MgU3R5bGVBdHRyaWJ1dG9yIGV4dGVuZHMgQXR0cmlidXRvciB7XG4gIHN0YXRpYyBrZXlzKG5vZGUpIHtcbiAgICByZXR1cm4gKG5vZGUuZ2V0QXR0cmlidXRlKFwic3R5bGVcIikgfHwgXCJcIikuc3BsaXQoXCI7XCIpLm1hcCgodmFsdWUpID0+IHZhbHVlLnNwbGl0KFwiOlwiKVswXS50cmltKCkpO1xuICB9XG4gIGFkZChub2RlLCB2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmNhbkFkZChub2RlLCB2YWx1ZSkgPyAobm9kZS5zdHlsZVtjYW1lbGl6ZSh0aGlzLmtleU5hbWUpXSA9IHZhbHVlLCAhMCkgOiAhMTtcbiAgfVxuICByZW1vdmUobm9kZSkge1xuICAgIG5vZGUuc3R5bGVbY2FtZWxpemUodGhpcy5rZXlOYW1lKV0gPSBcIlwiLCBub2RlLmdldEF0dHJpYnV0ZShcInN0eWxlXCIpIHx8IG5vZGUucmVtb3ZlQXR0cmlidXRlKFwic3R5bGVcIik7XG4gIH1cbiAgdmFsdWUobm9kZSkge1xuICAgIGNvbnN0IHZhbHVlID0gbm9kZS5zdHlsZVtjYW1lbGl6ZSh0aGlzLmtleU5hbWUpXTtcbiAgICByZXR1cm4gdGhpcy5jYW5BZGQobm9kZSwgdmFsdWUpID8gdmFsdWUgOiBcIlwiO1xuICB9XG59XG5jb25zdCBTdHlsZUF0dHJpYnV0b3IkMSA9IFN0eWxlQXR0cmlidXRvcjtcbmNsYXNzIEF0dHJpYnV0b3JTdG9yZSB7XG4gIGNvbnN0cnVjdG9yKGRvbU5vZGUpIHtcbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSB7fSwgdGhpcy5kb21Ob2RlID0gZG9tTm9kZSwgdGhpcy5idWlsZCgpO1xuICB9XG4gIGF0dHJpYnV0ZShhdHRyaWJ1dGUsIHZhbHVlKSB7XG4gICAgdmFsdWUgPyBhdHRyaWJ1dGUuYWRkKHRoaXMuZG9tTm9kZSwgdmFsdWUpICYmIChhdHRyaWJ1dGUudmFsdWUodGhpcy5kb21Ob2RlKSAhPSBudWxsID8gdGhpcy5hdHRyaWJ1dGVzW2F0dHJpYnV0ZS5hdHRyTmFtZV0gPSBhdHRyaWJ1dGUgOiBkZWxldGUgdGhpcy5hdHRyaWJ1dGVzW2F0dHJpYnV0ZS5hdHRyTmFtZV0pIDogKGF0dHJpYnV0ZS5yZW1vdmUodGhpcy5kb21Ob2RlKSwgZGVsZXRlIHRoaXMuYXR0cmlidXRlc1thdHRyaWJ1dGUuYXR0ck5hbWVdKTtcbiAgfVxuICBidWlsZCgpIHtcbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSB7fTtcbiAgICBjb25zdCBibG90ID0gUmVnaXN0cnkuZmluZCh0aGlzLmRvbU5vZGUpO1xuICAgIGlmIChibG90ID09IG51bGwpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IEF0dHJpYnV0b3Iua2V5cyh0aGlzLmRvbU5vZGUpLCBjbGFzc2VzID0gQ2xhc3NBdHRyaWJ1dG9yJDEua2V5cyh0aGlzLmRvbU5vZGUpLCBzdHlsZXMgPSBTdHlsZUF0dHJpYnV0b3IkMS5rZXlzKHRoaXMuZG9tTm9kZSk7XG4gICAgYXR0cmlidXRlcy5jb25jYXQoY2xhc3NlcykuY29uY2F0KHN0eWxlcykuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgY29uc3QgYXR0ciA9IGJsb3Quc2Nyb2xsLnF1ZXJ5KG5hbWUsIFNjb3BlLkFUVFJJQlVURSk7XG4gICAgICBhdHRyIGluc3RhbmNlb2YgQXR0cmlidXRvciAmJiAodGhpcy5hdHRyaWJ1dGVzW2F0dHIuYXR0ck5hbWVdID0gYXR0cik7XG4gICAgfSk7XG4gIH1cbiAgY29weSh0YXJnZXQpIHtcbiAgICBPYmplY3Qua2V5cyh0aGlzLmF0dHJpYnV0ZXMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmF0dHJpYnV0ZXNba2V5XS52YWx1ZSh0aGlzLmRvbU5vZGUpO1xuICAgICAgdGFyZ2V0LmZvcm1hdChrZXksIHZhbHVlKTtcbiAgICB9KTtcbiAgfVxuICBtb3ZlKHRhcmdldCkge1xuICAgIHRoaXMuY29weSh0YXJnZXQpLCBPYmplY3Qua2V5cyh0aGlzLmF0dHJpYnV0ZXMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgdGhpcy5hdHRyaWJ1dGVzW2tleV0ucmVtb3ZlKHRoaXMuZG9tTm9kZSk7XG4gICAgfSksIHRoaXMuYXR0cmlidXRlcyA9IHt9O1xuICB9XG4gIHZhbHVlcygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5hdHRyaWJ1dGVzKS5yZWR1Y2UoXG4gICAgICAoYXR0cmlidXRlcywgbmFtZSkgPT4gKGF0dHJpYnV0ZXNbbmFtZV0gPSB0aGlzLmF0dHJpYnV0ZXNbbmFtZV0udmFsdWUodGhpcy5kb21Ob2RlKSwgYXR0cmlidXRlcyksXG4gICAgICB7fVxuICAgICk7XG4gIH1cbn1cbmNvbnN0IEF0dHJpYnV0b3JTdG9yZSQxID0gQXR0cmlidXRvclN0b3JlLCBfU2hhZG93QmxvdCA9IGNsYXNzIF9TaGFkb3dCbG90IHtcbiAgY29uc3RydWN0b3Ioc2Nyb2xsLCBkb21Ob2RlKSB7XG4gICAgdGhpcy5zY3JvbGwgPSBzY3JvbGwsIHRoaXMuZG9tTm9kZSA9IGRvbU5vZGUsIFJlZ2lzdHJ5LmJsb3RzLnNldChkb21Ob2RlLCB0aGlzKSwgdGhpcy5wcmV2ID0gbnVsbCwgdGhpcy5uZXh0ID0gbnVsbDtcbiAgfVxuICBzdGF0aWMgY3JlYXRlKHJhd1ZhbHVlKSB7XG4gICAgaWYgKHRoaXMudGFnTmFtZSA9PSBudWxsKVxuICAgICAgdGhyb3cgbmV3IFBhcmNobWVudEVycm9yKFwiQmxvdCBkZWZpbml0aW9uIG1pc3NpbmcgdGFnTmFtZVwiKTtcbiAgICBsZXQgbm9kZSwgdmFsdWU7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodGhpcy50YWdOYW1lKSA/ICh0eXBlb2YgcmF3VmFsdWUgPT0gXCJzdHJpbmdcIiA/ICh2YWx1ZSA9IHJhd1ZhbHVlLnRvVXBwZXJDYXNlKCksIHBhcnNlSW50KHZhbHVlLCAxMCkudG9TdHJpbmcoKSA9PT0gdmFsdWUgJiYgKHZhbHVlID0gcGFyc2VJbnQodmFsdWUsIDEwKSkpIDogdHlwZW9mIHJhd1ZhbHVlID09IFwibnVtYmVyXCIgJiYgKHZhbHVlID0gcmF3VmFsdWUpLCB0eXBlb2YgdmFsdWUgPT0gXCJudW1iZXJcIiA/IG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRoaXMudGFnTmFtZVt2YWx1ZSAtIDFdKSA6IHZhbHVlICYmIHRoaXMudGFnTmFtZS5pbmRleE9mKHZhbHVlKSA+IC0xID8gbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodmFsdWUpIDogbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGhpcy50YWdOYW1lWzBdKSkgOiBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0aGlzLnRhZ05hbWUpLCB0aGlzLmNsYXNzTmFtZSAmJiBub2RlLmNsYXNzTGlzdC5hZGQodGhpcy5jbGFzc05hbWUpLCBub2RlO1xuICB9XG4gIC8vIEhhY2sgZm9yIGFjY2Vzc2luZyBpbmhlcml0ZWQgc3RhdGljIG1ldGhvZHNcbiAgZ2V0IHN0YXRpY3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3I7XG4gIH1cbiAgYXR0YWNoKCkge1xuICB9XG4gIGNsb25lKCkge1xuICAgIGNvbnN0IGRvbU5vZGUgPSB0aGlzLmRvbU5vZGUuY2xvbmVOb2RlKCExKTtcbiAgICByZXR1cm4gdGhpcy5zY3JvbGwuY3JlYXRlKGRvbU5vZGUpO1xuICB9XG4gIGRldGFjaCgpIHtcbiAgICB0aGlzLnBhcmVudCAhPSBudWxsICYmIHRoaXMucGFyZW50LnJlbW92ZUNoaWxkKHRoaXMpLCBSZWdpc3RyeS5ibG90cy5kZWxldGUodGhpcy5kb21Ob2RlKTtcbiAgfVxuICBkZWxldGVBdChpbmRleCwgbGVuZ3RoKSB7XG4gICAgdGhpcy5pc29sYXRlKGluZGV4LCBsZW5ndGgpLnJlbW92ZSgpO1xuICB9XG4gIGZvcm1hdEF0KGluZGV4LCBsZW5ndGgsIG5hbWUsIHZhbHVlKSB7XG4gICAgY29uc3QgYmxvdCA9IHRoaXMuaXNvbGF0ZShpbmRleCwgbGVuZ3RoKTtcbiAgICBpZiAodGhpcy5zY3JvbGwucXVlcnkobmFtZSwgU2NvcGUuQkxPVCkgIT0gbnVsbCAmJiB2YWx1ZSlcbiAgICAgIGJsb3Qud3JhcChuYW1lLCB2YWx1ZSk7XG4gICAgZWxzZSBpZiAodGhpcy5zY3JvbGwucXVlcnkobmFtZSwgU2NvcGUuQVRUUklCVVRFKSAhPSBudWxsKSB7XG4gICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLnNjcm9sbC5jcmVhdGUodGhpcy5zdGF0aWNzLnNjb3BlKTtcbiAgICAgIGJsb3Qud3JhcChwYXJlbnQpLCBwYXJlbnQuZm9ybWF0KG5hbWUsIHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgaW5zZXJ0QXQoaW5kZXgsIHZhbHVlLCBkZWYpIHtcbiAgICBjb25zdCBibG90ID0gZGVmID09IG51bGwgPyB0aGlzLnNjcm9sbC5jcmVhdGUoXCJ0ZXh0XCIsIHZhbHVlKSA6IHRoaXMuc2Nyb2xsLmNyZWF0ZSh2YWx1ZSwgZGVmKSwgcmVmID0gdGhpcy5zcGxpdChpbmRleCk7XG4gICAgdGhpcy5wYXJlbnQuaW5zZXJ0QmVmb3JlKGJsb3QsIHJlZiB8fCB2b2lkIDApO1xuICB9XG4gIGlzb2xhdGUoaW5kZXgsIGxlbmd0aCkge1xuICAgIGNvbnN0IHRhcmdldCA9IHRoaXMuc3BsaXQoaW5kZXgpO1xuICAgIGlmICh0YXJnZXQgPT0gbnVsbClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkF0dGVtcHQgdG8gaXNvbGF0ZSBhdCBlbmRcIik7XG4gICAgcmV0dXJuIHRhcmdldC5zcGxpdChsZW5ndGgpLCB0YXJnZXQ7XG4gIH1cbiAgbGVuZ3RoKCkge1xuICAgIHJldHVybiAxO1xuICB9XG4gIG9mZnNldChyb290ID0gdGhpcy5wYXJlbnQpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJlbnQgPT0gbnVsbCB8fCB0aGlzID09PSByb290ID8gMCA6IHRoaXMucGFyZW50LmNoaWxkcmVuLm9mZnNldCh0aGlzKSArIHRoaXMucGFyZW50Lm9mZnNldChyb290KTtcbiAgfVxuICBvcHRpbWl6ZShfY29udGV4dCkge1xuICAgIHRoaXMuc3RhdGljcy5yZXF1aXJlZENvbnRhaW5lciAmJiAhKHRoaXMucGFyZW50IGluc3RhbmNlb2YgdGhpcy5zdGF0aWNzLnJlcXVpcmVkQ29udGFpbmVyKSAmJiB0aGlzLndyYXAodGhpcy5zdGF0aWNzLnJlcXVpcmVkQ29udGFpbmVyLmJsb3ROYW1lKTtcbiAgfVxuICByZW1vdmUoKSB7XG4gICAgdGhpcy5kb21Ob2RlLnBhcmVudE5vZGUgIT0gbnVsbCAmJiB0aGlzLmRvbU5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmRvbU5vZGUpLCB0aGlzLmRldGFjaCgpO1xuICB9XG4gIHJlcGxhY2VXaXRoKG5hbWUsIHZhbHVlKSB7XG4gICAgY29uc3QgcmVwbGFjZW1lbnQgPSB0eXBlb2YgbmFtZSA9PSBcInN0cmluZ1wiID8gdGhpcy5zY3JvbGwuY3JlYXRlKG5hbWUsIHZhbHVlKSA6IG5hbWU7XG4gICAgcmV0dXJuIHRoaXMucGFyZW50ICE9IG51bGwgJiYgKHRoaXMucGFyZW50Lmluc2VydEJlZm9yZShyZXBsYWNlbWVudCwgdGhpcy5uZXh0IHx8IHZvaWQgMCksIHRoaXMucmVtb3ZlKCkpLCByZXBsYWNlbWVudDtcbiAgfVxuICBzcGxpdChpbmRleCwgX2ZvcmNlKSB7XG4gICAgcmV0dXJuIGluZGV4ID09PSAwID8gdGhpcyA6IHRoaXMubmV4dDtcbiAgfVxuICB1cGRhdGUoX211dGF0aW9ucywgX2NvbnRleHQpIHtcbiAgfVxuICB3cmFwKG5hbWUsIHZhbHVlKSB7XG4gICAgY29uc3Qgd3JhcHBlciA9IHR5cGVvZiBuYW1lID09IFwic3RyaW5nXCIgPyB0aGlzLnNjcm9sbC5jcmVhdGUobmFtZSwgdmFsdWUpIDogbmFtZTtcbiAgICBpZiAodGhpcy5wYXJlbnQgIT0gbnVsbCAmJiB0aGlzLnBhcmVudC5pbnNlcnRCZWZvcmUod3JhcHBlciwgdGhpcy5uZXh0IHx8IHZvaWQgMCksIHR5cGVvZiB3cmFwcGVyLmFwcGVuZENoaWxkICE9IFwiZnVuY3Rpb25cIilcbiAgICAgIHRocm93IG5ldyBQYXJjaG1lbnRFcnJvcihgQ2Fubm90IHdyYXAgJHtuYW1lfWApO1xuICAgIHJldHVybiB3cmFwcGVyLmFwcGVuZENoaWxkKHRoaXMpLCB3cmFwcGVyO1xuICB9XG59O1xuX1NoYWRvd0Jsb3QuYmxvdE5hbWUgPSBcImFic3RyYWN0XCI7XG5sZXQgU2hhZG93QmxvdCA9IF9TaGFkb3dCbG90O1xuY29uc3QgX0xlYWZCbG90ID0gY2xhc3MgX0xlYWZCbG90IGV4dGVuZHMgU2hhZG93QmxvdCB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSByZXByZXNlbnRlZCBieSBkb21Ob2RlIGlmIGl0IGlzIHRoaXMgQmxvdCdzIHR5cGVcbiAgICogTm8gY2hlY2tpbmcgdGhhdCBkb21Ob2RlIGNhbiByZXByZXNlbnQgdGhpcyBCbG90IHR5cGUgaXMgcmVxdWlyZWQgc29cbiAgICogYXBwbGljYXRpb25zIG5lZWRpbmcgaXQgc2hvdWxkIGNoZWNrIGV4dGVybmFsbHkgYmVmb3JlIGNhbGxpbmcuXG4gICAqL1xuICBzdGF0aWMgdmFsdWUoX2RvbU5vZGUpIHtcbiAgICByZXR1cm4gITA7XG4gIH1cbiAgLyoqXG4gICAqIEdpdmVuIGxvY2F0aW9uIHJlcHJlc2VudGVkIGJ5IG5vZGUgYW5kIG9mZnNldCBmcm9tIERPTSBTZWxlY3Rpb24gUmFuZ2UsXG4gICAqIHJldHVybiBpbmRleCB0byB0aGF0IGxvY2F0aW9uLlxuICAgKi9cbiAgaW5kZXgobm9kZSwgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIHRoaXMuZG9tTm9kZSA9PT0gbm9kZSB8fCB0aGlzLmRvbU5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24obm9kZSkgJiBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX0NPTlRBSU5FRF9CWSA/IE1hdGgubWluKG9mZnNldCwgMSkgOiAtMTtcbiAgfVxuICAvKipcbiAgICogR2l2ZW4gaW5kZXggdG8gbG9jYXRpb24gd2l0aGluIGJsb3QsIHJldHVybiBub2RlIGFuZCBvZmZzZXQgcmVwcmVzZW50aW5nXG4gICAqIHRoYXQgbG9jYXRpb24sIGNvbnN1bWFibGUgYnkgRE9NIFNlbGVjdGlvbiBSYW5nZVxuICAgKi9cbiAgcG9zaXRpb24oaW5kZXgsIF9pbmNsdXNpdmUpIHtcbiAgICBsZXQgb2Zmc2V0ID0gQXJyYXkuZnJvbSh0aGlzLnBhcmVudC5kb21Ob2RlLmNoaWxkTm9kZXMpLmluZGV4T2YodGhpcy5kb21Ob2RlKTtcbiAgICByZXR1cm4gaW5kZXggPiAwICYmIChvZmZzZXQgKz0gMSksIFt0aGlzLnBhcmVudC5kb21Ob2RlLCBvZmZzZXRdO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gdmFsdWUgcmVwcmVzZW50ZWQgYnkgdGhpcyBibG90XG4gICAqIFNob3VsZCBub3QgY2hhbmdlIHdpdGhvdXQgaW50ZXJhY3Rpb24gZnJvbSBBUEkgb3JcbiAgICogdXNlciBjaGFuZ2UgZGV0ZWN0YWJsZSBieSB1cGRhdGUoKVxuICAgKi9cbiAgdmFsdWUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIFt0aGlzLnN0YXRpY3MuYmxvdE5hbWVdOiB0aGlzLnN0YXRpY3MudmFsdWUodGhpcy5kb21Ob2RlKSB8fCAhMFxuICAgIH07XG4gIH1cbn07XG5fTGVhZkJsb3Quc2NvcGUgPSBTY29wZS5JTkxJTkVfQkxPVDtcbmxldCBMZWFmQmxvdCA9IF9MZWFmQmxvdDtcbmNvbnN0IExlYWZCbG90JDEgPSBMZWFmQmxvdDtcbmNsYXNzIExpbmtlZExpc3Qge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmhlYWQgPSBudWxsLCB0aGlzLnRhaWwgPSBudWxsLCB0aGlzLmxlbmd0aCA9IDA7XG4gIH1cbiAgYXBwZW5kKC4uLm5vZGVzKSB7XG4gICAgaWYgKHRoaXMuaW5zZXJ0QmVmb3JlKG5vZGVzWzBdLCBudWxsKSwgbm9kZXMubGVuZ3RoID4gMSkge1xuICAgICAgY29uc3QgcmVzdCA9IG5vZGVzLnNsaWNlKDEpO1xuICAgICAgdGhpcy5hcHBlbmQoLi4ucmVzdCk7XG4gICAgfVxuICB9XG4gIGF0KGluZGV4KSB7XG4gICAgY29uc3QgbmV4dCA9IHRoaXMuaXRlcmF0b3IoKTtcbiAgICBsZXQgY3VyID0gbmV4dCgpO1xuICAgIGZvciAoOyBjdXIgJiYgaW5kZXggPiAwOyApXG4gICAgICBpbmRleCAtPSAxLCBjdXIgPSBuZXh0KCk7XG4gICAgcmV0dXJuIGN1cjtcbiAgfVxuICBjb250YWlucyhub2RlKSB7XG4gICAgY29uc3QgbmV4dCA9IHRoaXMuaXRlcmF0b3IoKTtcbiAgICBsZXQgY3VyID0gbmV4dCgpO1xuICAgIGZvciAoOyBjdXI7ICkge1xuICAgICAgaWYgKGN1ciA9PT0gbm9kZSlcbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgY3VyID0gbmV4dCgpO1xuICAgIH1cbiAgICByZXR1cm4gITE7XG4gIH1cbiAgaW5kZXhPZihub2RlKSB7XG4gICAgY29uc3QgbmV4dCA9IHRoaXMuaXRlcmF0b3IoKTtcbiAgICBsZXQgY3VyID0gbmV4dCgpLCBpbmRleCA9IDA7XG4gICAgZm9yICg7IGN1cjsgKSB7XG4gICAgICBpZiAoY3VyID09PSBub2RlKVxuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICBpbmRleCArPSAxLCBjdXIgPSBuZXh0KCk7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuICBpbnNlcnRCZWZvcmUobm9kZSwgcmVmTm9kZSkge1xuICAgIG5vZGUgIT0gbnVsbCAmJiAodGhpcy5yZW1vdmUobm9kZSksIG5vZGUubmV4dCA9IHJlZk5vZGUsIHJlZk5vZGUgIT0gbnVsbCA/IChub2RlLnByZXYgPSByZWZOb2RlLnByZXYsIHJlZk5vZGUucHJldiAhPSBudWxsICYmIChyZWZOb2RlLnByZXYubmV4dCA9IG5vZGUpLCByZWZOb2RlLnByZXYgPSBub2RlLCByZWZOb2RlID09PSB0aGlzLmhlYWQgJiYgKHRoaXMuaGVhZCA9IG5vZGUpKSA6IHRoaXMudGFpbCAhPSBudWxsID8gKHRoaXMudGFpbC5uZXh0ID0gbm9kZSwgbm9kZS5wcmV2ID0gdGhpcy50YWlsLCB0aGlzLnRhaWwgPSBub2RlKSA6IChub2RlLnByZXYgPSBudWxsLCB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBub2RlKSwgdGhpcy5sZW5ndGggKz0gMSk7XG4gIH1cbiAgb2Zmc2V0KHRhcmdldCkge1xuICAgIGxldCBpbmRleCA9IDAsIGN1ciA9IHRoaXMuaGVhZDtcbiAgICBmb3IgKDsgY3VyICE9IG51bGw7ICkge1xuICAgICAgaWYgKGN1ciA9PT0gdGFyZ2V0KVxuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICBpbmRleCArPSBjdXIubGVuZ3RoKCksIGN1ciA9IGN1ci5uZXh0O1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgcmVtb3ZlKG5vZGUpIHtcbiAgICB0aGlzLmNvbnRhaW5zKG5vZGUpICYmIChub2RlLnByZXYgIT0gbnVsbCAmJiAobm9kZS5wcmV2Lm5leHQgPSBub2RlLm5leHQpLCBub2RlLm5leHQgIT0gbnVsbCAmJiAobm9kZS5uZXh0LnByZXYgPSBub2RlLnByZXYpLCBub2RlID09PSB0aGlzLmhlYWQgJiYgKHRoaXMuaGVhZCA9IG5vZGUubmV4dCksIG5vZGUgPT09IHRoaXMudGFpbCAmJiAodGhpcy50YWlsID0gbm9kZS5wcmV2KSwgdGhpcy5sZW5ndGggLT0gMSk7XG4gIH1cbiAgaXRlcmF0b3IoY3VyTm9kZSA9IHRoaXMuaGVhZCkge1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjb25zdCByZXQgPSBjdXJOb2RlO1xuICAgICAgcmV0dXJuIGN1ck5vZGUgIT0gbnVsbCAmJiAoY3VyTm9kZSA9IGN1ck5vZGUubmV4dCksIHJldDtcbiAgICB9O1xuICB9XG4gIGZpbmQoaW5kZXgsIGluY2x1c2l2ZSA9ICExKSB7XG4gICAgY29uc3QgbmV4dCA9IHRoaXMuaXRlcmF0b3IoKTtcbiAgICBsZXQgY3VyID0gbmV4dCgpO1xuICAgIGZvciAoOyBjdXI7ICkge1xuICAgICAgY29uc3QgbGVuZ3RoID0gY3VyLmxlbmd0aCgpO1xuICAgICAgaWYgKGluZGV4IDwgbGVuZ3RoIHx8IGluY2x1c2l2ZSAmJiBpbmRleCA9PT0gbGVuZ3RoICYmIChjdXIubmV4dCA9PSBudWxsIHx8IGN1ci5uZXh0Lmxlbmd0aCgpICE9PSAwKSlcbiAgICAgICAgcmV0dXJuIFtjdXIsIGluZGV4XTtcbiAgICAgIGluZGV4IC09IGxlbmd0aCwgY3VyID0gbmV4dCgpO1xuICAgIH1cbiAgICByZXR1cm4gW251bGwsIDBdO1xuICB9XG4gIGZvckVhY2goY2FsbGJhY2spIHtcbiAgICBjb25zdCBuZXh0ID0gdGhpcy5pdGVyYXRvcigpO1xuICAgIGxldCBjdXIgPSBuZXh0KCk7XG4gICAgZm9yICg7IGN1cjsgKVxuICAgICAgY2FsbGJhY2soY3VyKSwgY3VyID0gbmV4dCgpO1xuICB9XG4gIGZvckVhY2hBdChpbmRleCwgbGVuZ3RoLCBjYWxsYmFjaykge1xuICAgIGlmIChsZW5ndGggPD0gMClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBbc3RhcnROb2RlLCBvZmZzZXRdID0gdGhpcy5maW5kKGluZGV4KTtcbiAgICBsZXQgY3VySW5kZXggPSBpbmRleCAtIG9mZnNldDtcbiAgICBjb25zdCBuZXh0ID0gdGhpcy5pdGVyYXRvcihzdGFydE5vZGUpO1xuICAgIGxldCBjdXIgPSBuZXh0KCk7XG4gICAgZm9yICg7IGN1ciAmJiBjdXJJbmRleCA8IGluZGV4ICsgbGVuZ3RoOyApIHtcbiAgICAgIGNvbnN0IGN1ckxlbmd0aCA9IGN1ci5sZW5ndGgoKTtcbiAgICAgIGluZGV4ID4gY3VySW5kZXggPyBjYWxsYmFjayhcbiAgICAgICAgY3VyLFxuICAgICAgICBpbmRleCAtIGN1ckluZGV4LFxuICAgICAgICBNYXRoLm1pbihsZW5ndGgsIGN1ckluZGV4ICsgY3VyTGVuZ3RoIC0gaW5kZXgpXG4gICAgICApIDogY2FsbGJhY2soY3VyLCAwLCBNYXRoLm1pbihjdXJMZW5ndGgsIGluZGV4ICsgbGVuZ3RoIC0gY3VySW5kZXgpKSwgY3VySW5kZXggKz0gY3VyTGVuZ3RoLCBjdXIgPSBuZXh0KCk7XG4gICAgfVxuICB9XG4gIG1hcChjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLnJlZHVjZSgobWVtbywgY3VyKSA9PiAobWVtby5wdXNoKGNhbGxiYWNrKGN1cikpLCBtZW1vKSwgW10pO1xuICB9XG4gIHJlZHVjZShjYWxsYmFjaywgbWVtbykge1xuICAgIGNvbnN0IG5leHQgPSB0aGlzLml0ZXJhdG9yKCk7XG4gICAgbGV0IGN1ciA9IG5leHQoKTtcbiAgICBmb3IgKDsgY3VyOyApXG4gICAgICBtZW1vID0gY2FsbGJhY2sobWVtbywgY3VyKSwgY3VyID0gbmV4dCgpO1xuICAgIHJldHVybiBtZW1vO1xuICB9XG59XG5mdW5jdGlvbiBtYWtlQXR0YWNoZWRCbG90KG5vZGUsIHNjcm9sbCkge1xuICBjb25zdCBmb3VuZCA9IHNjcm9sbC5maW5kKG5vZGUpO1xuICBpZiAoZm91bmQpXG4gICAgcmV0dXJuIGZvdW5kO1xuICB0cnkge1xuICAgIHJldHVybiBzY3JvbGwuY3JlYXRlKG5vZGUpO1xuICB9IGNhdGNoIHtcbiAgICBjb25zdCBibG90ID0gc2Nyb2xsLmNyZWF0ZShTY29wZS5JTkxJTkUpO1xuICAgIHJldHVybiBBcnJheS5mcm9tKG5vZGUuY2hpbGROb2RlcykuZm9yRWFjaCgoY2hpbGQpID0+IHtcbiAgICAgIGJsb3QuZG9tTm9kZS5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgfSksIG5vZGUucGFyZW50Tm9kZSAmJiBub2RlLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKGJsb3QuZG9tTm9kZSwgbm9kZSksIGJsb3QuYXR0YWNoKCksIGJsb3Q7XG4gIH1cbn1cbmNvbnN0IF9QYXJlbnRCbG90ID0gY2xhc3MgX1BhcmVudEJsb3QgZXh0ZW5kcyBTaGFkb3dCbG90IHtcbiAgY29uc3RydWN0b3Ioc2Nyb2xsLCBkb21Ob2RlKSB7XG4gICAgc3VwZXIoc2Nyb2xsLCBkb21Ob2RlKSwgdGhpcy51aU5vZGUgPSBudWxsLCB0aGlzLmJ1aWxkKCk7XG4gIH1cbiAgYXBwZW5kQ2hpbGQob3RoZXIpIHtcbiAgICB0aGlzLmluc2VydEJlZm9yZShvdGhlcik7XG4gIH1cbiAgYXR0YWNoKCkge1xuICAgIHN1cGVyLmF0dGFjaCgpLCB0aGlzLmNoaWxkcmVuLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgICBjaGlsZC5hdHRhY2goKTtcbiAgICB9KTtcbiAgfVxuICBhdHRhY2hVSShub2RlKSB7XG4gICAgdGhpcy51aU5vZGUgIT0gbnVsbCAmJiB0aGlzLnVpTm9kZS5yZW1vdmUoKSwgdGhpcy51aU5vZGUgPSBub2RlLCBfUGFyZW50QmxvdC51aUNsYXNzICYmIHRoaXMudWlOb2RlLmNsYXNzTGlzdC5hZGQoX1BhcmVudEJsb3QudWlDbGFzcyksIHRoaXMudWlOb2RlLnNldEF0dHJpYnV0ZShcImNvbnRlbnRlZGl0YWJsZVwiLCBcImZhbHNlXCIpLCB0aGlzLmRvbU5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMudWlOb2RlLCB0aGlzLmRvbU5vZGUuZmlyc3RDaGlsZCk7XG4gIH1cbiAgLyoqXG4gICAqIENhbGxlZCBkdXJpbmcgY29uc3RydWN0aW9uLCBzaG91bGQgZmlsbCBpdHMgb3duIGNoaWxkcmVuIExpbmtlZExpc3QuXG4gICAqL1xuICBidWlsZCgpIHtcbiAgICB0aGlzLmNoaWxkcmVuID0gbmV3IExpbmtlZExpc3QoKSwgQXJyYXkuZnJvbSh0aGlzLmRvbU5vZGUuY2hpbGROb2RlcykuZmlsdGVyKChub2RlKSA9PiBub2RlICE9PSB0aGlzLnVpTm9kZSkucmV2ZXJzZSgpLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gbWFrZUF0dGFjaGVkQmxvdChub2RlLCB0aGlzLnNjcm9sbCk7XG4gICAgICAgIHRoaXMuaW5zZXJ0QmVmb3JlKGNoaWxkLCB0aGlzLmNoaWxkcmVuLmhlYWQgfHwgdm9pZCAwKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgUGFyY2htZW50RXJyb3IpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZGVsZXRlQXQoaW5kZXgsIGxlbmd0aCkge1xuICAgIGlmIChpbmRleCA9PT0gMCAmJiBsZW5ndGggPT09IHRoaXMubGVuZ3RoKCkpXG4gICAgICByZXR1cm4gdGhpcy5yZW1vdmUoKTtcbiAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2hBdChpbmRleCwgbGVuZ3RoLCAoY2hpbGQsIG9mZnNldCwgY2hpbGRMZW5ndGgpID0+IHtcbiAgICAgIGNoaWxkLmRlbGV0ZUF0KG9mZnNldCwgY2hpbGRMZW5ndGgpO1xuICAgIH0pO1xuICB9XG4gIGRlc2NlbmRhbnQoY3JpdGVyaWEsIGluZGV4ID0gMCkge1xuICAgIGNvbnN0IFtjaGlsZCwgb2Zmc2V0XSA9IHRoaXMuY2hpbGRyZW4uZmluZChpbmRleCk7XG4gICAgcmV0dXJuIGNyaXRlcmlhLmJsb3ROYW1lID09IG51bGwgJiYgY3JpdGVyaWEoY2hpbGQpIHx8IGNyaXRlcmlhLmJsb3ROYW1lICE9IG51bGwgJiYgY2hpbGQgaW5zdGFuY2VvZiBjcml0ZXJpYSA/IFtjaGlsZCwgb2Zmc2V0XSA6IGNoaWxkIGluc3RhbmNlb2YgX1BhcmVudEJsb3QgPyBjaGlsZC5kZXNjZW5kYW50KGNyaXRlcmlhLCBvZmZzZXQpIDogW251bGwsIC0xXTtcbiAgfVxuICBkZXNjZW5kYW50cyhjcml0ZXJpYSwgaW5kZXggPSAwLCBsZW5ndGggPSBOdW1iZXIuTUFYX1ZBTFVFKSB7XG4gICAgbGV0IGRlc2NlbmRhbnRzID0gW10sIGxlbmd0aExlZnQgPSBsZW5ndGg7XG4gICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4uZm9yRWFjaEF0KFxuICAgICAgaW5kZXgsXG4gICAgICBsZW5ndGgsXG4gICAgICAoY2hpbGQsIGNoaWxkSW5kZXgsIGNoaWxkTGVuZ3RoKSA9PiB7XG4gICAgICAgIChjcml0ZXJpYS5ibG90TmFtZSA9PSBudWxsICYmIGNyaXRlcmlhKGNoaWxkKSB8fCBjcml0ZXJpYS5ibG90TmFtZSAhPSBudWxsICYmIGNoaWxkIGluc3RhbmNlb2YgY3JpdGVyaWEpICYmIGRlc2NlbmRhbnRzLnB1c2goY2hpbGQpLCBjaGlsZCBpbnN0YW5jZW9mIF9QYXJlbnRCbG90ICYmIChkZXNjZW5kYW50cyA9IGRlc2NlbmRhbnRzLmNvbmNhdChcbiAgICAgICAgICBjaGlsZC5kZXNjZW5kYW50cyhjcml0ZXJpYSwgY2hpbGRJbmRleCwgbGVuZ3RoTGVmdClcbiAgICAgICAgKSksIGxlbmd0aExlZnQgLT0gY2hpbGRMZW5ndGg7XG4gICAgICB9XG4gICAgKSwgZGVzY2VuZGFudHM7XG4gIH1cbiAgZGV0YWNoKCkge1xuICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQpID0+IHtcbiAgICAgIGNoaWxkLmRldGFjaCgpO1xuICAgIH0pLCBzdXBlci5kZXRhY2goKTtcbiAgfVxuICBlbmZvcmNlQWxsb3dlZENoaWxkcmVuKCkge1xuICAgIGxldCBkb25lID0gITE7XG4gICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKChjaGlsZCkgPT4ge1xuICAgICAgZG9uZSB8fCB0aGlzLnN0YXRpY3MuYWxsb3dlZENoaWxkcmVuLnNvbWUoXG4gICAgICAgIChkZWYpID0+IGNoaWxkIGluc3RhbmNlb2YgZGVmXG4gICAgICApIHx8IChjaGlsZC5zdGF0aWNzLnNjb3BlID09PSBTY29wZS5CTE9DS19CTE9UID8gKGNoaWxkLm5leHQgIT0gbnVsbCAmJiB0aGlzLnNwbGl0QWZ0ZXIoY2hpbGQpLCBjaGlsZC5wcmV2ICE9IG51bGwgJiYgdGhpcy5zcGxpdEFmdGVyKGNoaWxkLnByZXYpLCBjaGlsZC5wYXJlbnQudW53cmFwKCksIGRvbmUgPSAhMCkgOiBjaGlsZCBpbnN0YW5jZW9mIF9QYXJlbnRCbG90ID8gY2hpbGQudW53cmFwKCkgOiBjaGlsZC5yZW1vdmUoKSk7XG4gICAgfSk7XG4gIH1cbiAgZm9ybWF0QXQoaW5kZXgsIGxlbmd0aCwgbmFtZSwgdmFsdWUpIHtcbiAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2hBdChpbmRleCwgbGVuZ3RoLCAoY2hpbGQsIG9mZnNldCwgY2hpbGRMZW5ndGgpID0+IHtcbiAgICAgIGNoaWxkLmZvcm1hdEF0KG9mZnNldCwgY2hpbGRMZW5ndGgsIG5hbWUsIHZhbHVlKTtcbiAgICB9KTtcbiAgfVxuICBpbnNlcnRBdChpbmRleCwgdmFsdWUsIGRlZikge1xuICAgIGNvbnN0IFtjaGlsZCwgb2Zmc2V0XSA9IHRoaXMuY2hpbGRyZW4uZmluZChpbmRleCk7XG4gICAgaWYgKGNoaWxkKVxuICAgICAgY2hpbGQuaW5zZXJ0QXQob2Zmc2V0LCB2YWx1ZSwgZGVmKTtcbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IGJsb3QgPSBkZWYgPT0gbnVsbCA/IHRoaXMuc2Nyb2xsLmNyZWF0ZShcInRleHRcIiwgdmFsdWUpIDogdGhpcy5zY3JvbGwuY3JlYXRlKHZhbHVlLCBkZWYpO1xuICAgICAgdGhpcy5hcHBlbmRDaGlsZChibG90KTtcbiAgICB9XG4gIH1cbiAgaW5zZXJ0QmVmb3JlKGNoaWxkQmxvdCwgcmVmQmxvdCkge1xuICAgIGNoaWxkQmxvdC5wYXJlbnQgIT0gbnVsbCAmJiBjaGlsZEJsb3QucGFyZW50LmNoaWxkcmVuLnJlbW92ZShjaGlsZEJsb3QpO1xuICAgIGxldCByZWZEb21Ob2RlID0gbnVsbDtcbiAgICB0aGlzLmNoaWxkcmVuLmluc2VydEJlZm9yZShjaGlsZEJsb3QsIHJlZkJsb3QgfHwgbnVsbCksIGNoaWxkQmxvdC5wYXJlbnQgPSB0aGlzLCByZWZCbG90ICE9IG51bGwgJiYgKHJlZkRvbU5vZGUgPSByZWZCbG90LmRvbU5vZGUpLCAodGhpcy5kb21Ob2RlLnBhcmVudE5vZGUgIT09IGNoaWxkQmxvdC5kb21Ob2RlIHx8IHRoaXMuZG9tTm9kZS5uZXh0U2libGluZyAhPT0gcmVmRG9tTm9kZSkgJiYgdGhpcy5kb21Ob2RlLmluc2VydEJlZm9yZShjaGlsZEJsb3QuZG9tTm9kZSwgcmVmRG9tTm9kZSksIGNoaWxkQmxvdC5hdHRhY2goKTtcbiAgfVxuICBsZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4ucmVkdWNlKChtZW1vLCBjaGlsZCkgPT4gbWVtbyArIGNoaWxkLmxlbmd0aCgpLCAwKTtcbiAgfVxuICBtb3ZlQ2hpbGRyZW4odGFyZ2V0UGFyZW50LCByZWZOb2RlKSB7XG4gICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKChjaGlsZCkgPT4ge1xuICAgICAgdGFyZ2V0UGFyZW50Lmluc2VydEJlZm9yZShjaGlsZCwgcmVmTm9kZSk7XG4gICAgfSk7XG4gIH1cbiAgb3B0aW1pemUoY29udGV4dCkge1xuICAgIGlmIChzdXBlci5vcHRpbWl6ZShjb250ZXh0KSwgdGhpcy5lbmZvcmNlQWxsb3dlZENoaWxkcmVuKCksIHRoaXMudWlOb2RlICE9IG51bGwgJiYgdGhpcy51aU5vZGUgIT09IHRoaXMuZG9tTm9kZS5maXJzdENoaWxkICYmIHRoaXMuZG9tTm9kZS5pbnNlcnRCZWZvcmUodGhpcy51aU5vZGUsIHRoaXMuZG9tTm9kZS5maXJzdENoaWxkKSwgdGhpcy5jaGlsZHJlbi5sZW5ndGggPT09IDApXG4gICAgICBpZiAodGhpcy5zdGF0aWNzLmRlZmF1bHRDaGlsZCAhPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gdGhpcy5zY3JvbGwuY3JlYXRlKHRoaXMuc3RhdGljcy5kZWZhdWx0Q2hpbGQuYmxvdE5hbWUpO1xuICAgICAgICB0aGlzLmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICB9XG4gIHBhdGgoaW5kZXgsIGluY2x1c2l2ZSA9ICExKSB7XG4gICAgY29uc3QgW2NoaWxkLCBvZmZzZXRdID0gdGhpcy5jaGlsZHJlbi5maW5kKGluZGV4LCBpbmNsdXNpdmUpLCBwb3NpdGlvbiA9IFtbdGhpcywgaW5kZXhdXTtcbiAgICByZXR1cm4gY2hpbGQgaW5zdGFuY2VvZiBfUGFyZW50QmxvdCA/IHBvc2l0aW9uLmNvbmNhdChjaGlsZC5wYXRoKG9mZnNldCwgaW5jbHVzaXZlKSkgOiAoY2hpbGQgIT0gbnVsbCAmJiBwb3NpdGlvbi5wdXNoKFtjaGlsZCwgb2Zmc2V0XSksIHBvc2l0aW9uKTtcbiAgfVxuICByZW1vdmVDaGlsZChjaGlsZCkge1xuICAgIHRoaXMuY2hpbGRyZW4ucmVtb3ZlKGNoaWxkKTtcbiAgfVxuICByZXBsYWNlV2l0aChuYW1lLCB2YWx1ZSkge1xuICAgIGNvbnN0IHJlcGxhY2VtZW50ID0gdHlwZW9mIG5hbWUgPT0gXCJzdHJpbmdcIiA/IHRoaXMuc2Nyb2xsLmNyZWF0ZShuYW1lLCB2YWx1ZSkgOiBuYW1lO1xuICAgIHJldHVybiByZXBsYWNlbWVudCBpbnN0YW5jZW9mIF9QYXJlbnRCbG90ICYmIHRoaXMubW92ZUNoaWxkcmVuKHJlcGxhY2VtZW50KSwgc3VwZXIucmVwbGFjZVdpdGgocmVwbGFjZW1lbnQpO1xuICB9XG4gIHNwbGl0KGluZGV4LCBmb3JjZSA9ICExKSB7XG4gICAgaWYgKCFmb3JjZSkge1xuICAgICAgaWYgKGluZGV4ID09PSAwKVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIGlmIChpbmRleCA9PT0gdGhpcy5sZW5ndGgoKSlcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dDtcbiAgICB9XG4gICAgY29uc3QgYWZ0ZXIgPSB0aGlzLmNsb25lKCk7XG4gICAgcmV0dXJuIHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50Lmluc2VydEJlZm9yZShhZnRlciwgdGhpcy5uZXh0IHx8IHZvaWQgMCksIHRoaXMuY2hpbGRyZW4uZm9yRWFjaEF0KGluZGV4LCB0aGlzLmxlbmd0aCgpLCAoY2hpbGQsIG9mZnNldCwgX2xlbmd0aCkgPT4ge1xuICAgICAgY29uc3Qgc3BsaXQgPSBjaGlsZC5zcGxpdChvZmZzZXQsIGZvcmNlKTtcbiAgICAgIHNwbGl0ICE9IG51bGwgJiYgYWZ0ZXIuYXBwZW5kQ2hpbGQoc3BsaXQpO1xuICAgIH0pLCBhZnRlcjtcbiAgfVxuICBzcGxpdEFmdGVyKGNoaWxkKSB7XG4gICAgY29uc3QgYWZ0ZXIgPSB0aGlzLmNsb25lKCk7XG4gICAgZm9yICg7IGNoaWxkLm5leHQgIT0gbnVsbDsgKVxuICAgICAgYWZ0ZXIuYXBwZW5kQ2hpbGQoY2hpbGQubmV4dCk7XG4gICAgcmV0dXJuIHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50Lmluc2VydEJlZm9yZShhZnRlciwgdGhpcy5uZXh0IHx8IHZvaWQgMCksIGFmdGVyO1xuICB9XG4gIHVud3JhcCgpIHtcbiAgICB0aGlzLnBhcmVudCAmJiB0aGlzLm1vdmVDaGlsZHJlbih0aGlzLnBhcmVudCwgdGhpcy5uZXh0IHx8IHZvaWQgMCksIHRoaXMucmVtb3ZlKCk7XG4gIH1cbiAgdXBkYXRlKG11dGF0aW9ucywgX2NvbnRleHQpIHtcbiAgICBjb25zdCBhZGRlZE5vZGVzID0gW10sIHJlbW92ZWROb2RlcyA9IFtdO1xuICAgIG11dGF0aW9ucy5mb3JFYWNoKChtdXRhdGlvbikgPT4ge1xuICAgICAgbXV0YXRpb24udGFyZ2V0ID09PSB0aGlzLmRvbU5vZGUgJiYgbXV0YXRpb24udHlwZSA9PT0gXCJjaGlsZExpc3RcIiAmJiAoYWRkZWROb2Rlcy5wdXNoKC4uLm11dGF0aW9uLmFkZGVkTm9kZXMpLCByZW1vdmVkTm9kZXMucHVzaCguLi5tdXRhdGlvbi5yZW1vdmVkTm9kZXMpKTtcbiAgICB9KSwgcmVtb3ZlZE5vZGVzLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgIGlmIChub2RlLnBhcmVudE5vZGUgIT0gbnVsbCAmJiAvLyBAdHMtZXhwZWN0LWVycm9yIEZpeCBtZSBsYXRlclxuICAgICAgbm9kZS50YWdOYW1lICE9PSBcIklGUkFNRVwiICYmIGRvY3VtZW50LmJvZHkuY29tcGFyZURvY3VtZW50UG9zaXRpb24obm9kZSkgJiBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX0NPTlRBSU5FRF9CWSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgYmxvdCA9IHRoaXMuc2Nyb2xsLmZpbmQobm9kZSk7XG4gICAgICBibG90ICE9IG51bGwgJiYgKGJsb3QuZG9tTm9kZS5wYXJlbnROb2RlID09IG51bGwgfHwgYmxvdC5kb21Ob2RlLnBhcmVudE5vZGUgPT09IHRoaXMuZG9tTm9kZSkgJiYgYmxvdC5kZXRhY2goKTtcbiAgICB9KSwgYWRkZWROb2Rlcy5maWx0ZXIoKG5vZGUpID0+IG5vZGUucGFyZW50Tm9kZSA9PT0gdGhpcy5kb21Ob2RlICYmIG5vZGUgIT09IHRoaXMudWlOb2RlKS5zb3J0KChhLCBiKSA9PiBhID09PSBiID8gMCA6IGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oYikgJiBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX0ZPTExPV0lORyA/IDEgOiAtMSkuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgbGV0IHJlZkJsb3QgPSBudWxsO1xuICAgICAgbm9kZS5uZXh0U2libGluZyAhPSBudWxsICYmIChyZWZCbG90ID0gdGhpcy5zY3JvbGwuZmluZChub2RlLm5leHRTaWJsaW5nKSk7XG4gICAgICBjb25zdCBibG90ID0gbWFrZUF0dGFjaGVkQmxvdChub2RlLCB0aGlzLnNjcm9sbCk7XG4gICAgICAoYmxvdC5uZXh0ICE9PSByZWZCbG90IHx8IGJsb3QubmV4dCA9PSBudWxsKSAmJiAoYmxvdC5wYXJlbnQgIT0gbnVsbCAmJiBibG90LnBhcmVudC5yZW1vdmVDaGlsZCh0aGlzKSwgdGhpcy5pbnNlcnRCZWZvcmUoYmxvdCwgcmVmQmxvdCB8fCB2b2lkIDApKTtcbiAgICB9KSwgdGhpcy5lbmZvcmNlQWxsb3dlZENoaWxkcmVuKCk7XG4gIH1cbn07XG5fUGFyZW50QmxvdC51aUNsYXNzID0gXCJcIjtcbmxldCBQYXJlbnRCbG90ID0gX1BhcmVudEJsb3Q7XG5jb25zdCBQYXJlbnRCbG90JDEgPSBQYXJlbnRCbG90O1xuZnVuY3Rpb24gaXNFcXVhbChvYmoxLCBvYmoyKSB7XG4gIGlmIChPYmplY3Qua2V5cyhvYmoxKS5sZW5ndGggIT09IE9iamVjdC5rZXlzKG9iajIpLmxlbmd0aClcbiAgICByZXR1cm4gITE7XG4gIGZvciAoY29uc3QgcHJvcCBpbiBvYmoxKVxuICAgIGlmIChvYmoxW3Byb3BdICE9PSBvYmoyW3Byb3BdKVxuICAgICAgcmV0dXJuICExO1xuICByZXR1cm4gITA7XG59XG5jb25zdCBfSW5saW5lQmxvdCA9IGNsYXNzIF9JbmxpbmVCbG90IGV4dGVuZHMgUGFyZW50QmxvdCQxIHtcbiAgc3RhdGljIGNyZWF0ZSh2YWx1ZSkge1xuICAgIHJldHVybiBzdXBlci5jcmVhdGUodmFsdWUpO1xuICB9XG4gIHN0YXRpYyBmb3JtYXRzKGRvbU5vZGUsIHNjcm9sbCkge1xuICAgIGNvbnN0IG1hdGNoMiA9IHNjcm9sbC5xdWVyeShfSW5saW5lQmxvdC5ibG90TmFtZSk7XG4gICAgaWYgKCEobWF0Y2gyICE9IG51bGwgJiYgZG9tTm9kZS50YWdOYW1lID09PSBtYXRjaDIudGFnTmFtZSkpIHtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy50YWdOYW1lID09IFwic3RyaW5nXCIpXG4gICAgICAgIHJldHVybiAhMDtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMudGFnTmFtZSkpXG4gICAgICAgIHJldHVybiBkb21Ob2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gIH1cbiAgY29uc3RydWN0b3Ioc2Nyb2xsLCBkb21Ob2RlKSB7XG4gICAgc3VwZXIoc2Nyb2xsLCBkb21Ob2RlKSwgdGhpcy5hdHRyaWJ1dGVzID0gbmV3IEF0dHJpYnV0b3JTdG9yZSQxKHRoaXMuZG9tTm9kZSk7XG4gIH1cbiAgZm9ybWF0KG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKG5hbWUgPT09IHRoaXMuc3RhdGljcy5ibG90TmFtZSAmJiAhdmFsdWUpXG4gICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgICAgIGNoaWxkIGluc3RhbmNlb2YgX0lubGluZUJsb3QgfHwgKGNoaWxkID0gY2hpbGQud3JhcChfSW5saW5lQmxvdC5ibG90TmFtZSwgITApKSwgdGhpcy5hdHRyaWJ1dGVzLmNvcHkoY2hpbGQpO1xuICAgICAgfSksIHRoaXMudW53cmFwKCk7XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCBmb3JtYXQgPSB0aGlzLnNjcm9sbC5xdWVyeShuYW1lLCBTY29wZS5JTkxJTkUpO1xuICAgICAgaWYgKGZvcm1hdCA9PSBudWxsKVxuICAgICAgICByZXR1cm47XG4gICAgICBmb3JtYXQgaW5zdGFuY2VvZiBBdHRyaWJ1dG9yID8gdGhpcy5hdHRyaWJ1dGVzLmF0dHJpYnV0ZShmb3JtYXQsIHZhbHVlKSA6IHZhbHVlICYmIChuYW1lICE9PSB0aGlzLnN0YXRpY3MuYmxvdE5hbWUgfHwgdGhpcy5mb3JtYXRzKClbbmFtZV0gIT09IHZhbHVlKSAmJiB0aGlzLnJlcGxhY2VXaXRoKG5hbWUsIHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgZm9ybWF0cygpIHtcbiAgICBjb25zdCBmb3JtYXRzID0gdGhpcy5hdHRyaWJ1dGVzLnZhbHVlcygpLCBmb3JtYXQgPSB0aGlzLnN0YXRpY3MuZm9ybWF0cyh0aGlzLmRvbU5vZGUsIHRoaXMuc2Nyb2xsKTtcbiAgICByZXR1cm4gZm9ybWF0ICE9IG51bGwgJiYgKGZvcm1hdHNbdGhpcy5zdGF0aWNzLmJsb3ROYW1lXSA9IGZvcm1hdCksIGZvcm1hdHM7XG4gIH1cbiAgZm9ybWF0QXQoaW5kZXgsIGxlbmd0aCwgbmFtZSwgdmFsdWUpIHtcbiAgICB0aGlzLmZvcm1hdHMoKVtuYW1lXSAhPSBudWxsIHx8IHRoaXMuc2Nyb2xsLnF1ZXJ5KG5hbWUsIFNjb3BlLkFUVFJJQlVURSkgPyB0aGlzLmlzb2xhdGUoaW5kZXgsIGxlbmd0aCkuZm9ybWF0KG5hbWUsIHZhbHVlKSA6IHN1cGVyLmZvcm1hdEF0KGluZGV4LCBsZW5ndGgsIG5hbWUsIHZhbHVlKTtcbiAgfVxuICBvcHRpbWl6ZShjb250ZXh0KSB7XG4gICAgc3VwZXIub3B0aW1pemUoY29udGV4dCk7XG4gICAgY29uc3QgZm9ybWF0cyA9IHRoaXMuZm9ybWF0cygpO1xuICAgIGlmIChPYmplY3Qua2V5cyhmb3JtYXRzKS5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gdGhpcy51bndyYXAoKTtcbiAgICBjb25zdCBuZXh0ID0gdGhpcy5uZXh0O1xuICAgIG5leHQgaW5zdGFuY2VvZiBfSW5saW5lQmxvdCAmJiBuZXh0LnByZXYgPT09IHRoaXMgJiYgaXNFcXVhbChmb3JtYXRzLCBuZXh0LmZvcm1hdHMoKSkgJiYgKG5leHQubW92ZUNoaWxkcmVuKHRoaXMpLCBuZXh0LnJlbW92ZSgpKTtcbiAgfVxuICByZXBsYWNlV2l0aChuYW1lLCB2YWx1ZSkge1xuICAgIGNvbnN0IHJlcGxhY2VtZW50ID0gc3VwZXIucmVwbGFjZVdpdGgobmFtZSwgdmFsdWUpO1xuICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZXMuY29weShyZXBsYWNlbWVudCksIHJlcGxhY2VtZW50O1xuICB9XG4gIHVwZGF0ZShtdXRhdGlvbnMsIGNvbnRleHQpIHtcbiAgICBzdXBlci51cGRhdGUobXV0YXRpb25zLCBjb250ZXh0KSwgbXV0YXRpb25zLnNvbWUoXG4gICAgICAobXV0YXRpb24pID0+IG11dGF0aW9uLnRhcmdldCA9PT0gdGhpcy5kb21Ob2RlICYmIG11dGF0aW9uLnR5cGUgPT09IFwiYXR0cmlidXRlc1wiXG4gICAgKSAmJiB0aGlzLmF0dHJpYnV0ZXMuYnVpbGQoKTtcbiAgfVxuICB3cmFwKG5hbWUsIHZhbHVlKSB7XG4gICAgY29uc3Qgd3JhcHBlciA9IHN1cGVyLndyYXAobmFtZSwgdmFsdWUpO1xuICAgIHJldHVybiB3cmFwcGVyIGluc3RhbmNlb2YgX0lubGluZUJsb3QgJiYgdGhpcy5hdHRyaWJ1dGVzLm1vdmUod3JhcHBlciksIHdyYXBwZXI7XG4gIH1cbn07XG5fSW5saW5lQmxvdC5hbGxvd2VkQ2hpbGRyZW4gPSBbX0lubGluZUJsb3QsIExlYWZCbG90JDFdLCBfSW5saW5lQmxvdC5ibG90TmFtZSA9IFwiaW5saW5lXCIsIF9JbmxpbmVCbG90LnNjb3BlID0gU2NvcGUuSU5MSU5FX0JMT1QsIF9JbmxpbmVCbG90LnRhZ05hbWUgPSBcIlNQQU5cIjtcbmxldCBJbmxpbmVCbG90ID0gX0lubGluZUJsb3Q7XG5jb25zdCBJbmxpbmVCbG90JDEgPSBJbmxpbmVCbG90LCBfQmxvY2tCbG90ID0gY2xhc3MgX0Jsb2NrQmxvdCBleHRlbmRzIFBhcmVudEJsb3QkMSB7XG4gIHN0YXRpYyBjcmVhdGUodmFsdWUpIHtcbiAgICByZXR1cm4gc3VwZXIuY3JlYXRlKHZhbHVlKTtcbiAgfVxuICBzdGF0aWMgZm9ybWF0cyhkb21Ob2RlLCBzY3JvbGwpIHtcbiAgICBjb25zdCBtYXRjaDIgPSBzY3JvbGwucXVlcnkoX0Jsb2NrQmxvdC5ibG90TmFtZSk7XG4gICAgaWYgKCEobWF0Y2gyICE9IG51bGwgJiYgZG9tTm9kZS50YWdOYW1lID09PSBtYXRjaDIudGFnTmFtZSkpIHtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy50YWdOYW1lID09IFwic3RyaW5nXCIpXG4gICAgICAgIHJldHVybiAhMDtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMudGFnTmFtZSkpXG4gICAgICAgIHJldHVybiBkb21Ob2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gIH1cbiAgY29uc3RydWN0b3Ioc2Nyb2xsLCBkb21Ob2RlKSB7XG4gICAgc3VwZXIoc2Nyb2xsLCBkb21Ob2RlKSwgdGhpcy5hdHRyaWJ1dGVzID0gbmV3IEF0dHJpYnV0b3JTdG9yZSQxKHRoaXMuZG9tTm9kZSk7XG4gIH1cbiAgZm9ybWF0KG5hbWUsIHZhbHVlKSB7XG4gICAgY29uc3QgZm9ybWF0ID0gdGhpcy5zY3JvbGwucXVlcnkobmFtZSwgU2NvcGUuQkxPQ0spO1xuICAgIGZvcm1hdCAhPSBudWxsICYmIChmb3JtYXQgaW5zdGFuY2VvZiBBdHRyaWJ1dG9yID8gdGhpcy5hdHRyaWJ1dGVzLmF0dHJpYnV0ZShmb3JtYXQsIHZhbHVlKSA6IG5hbWUgPT09IHRoaXMuc3RhdGljcy5ibG90TmFtZSAmJiAhdmFsdWUgPyB0aGlzLnJlcGxhY2VXaXRoKF9CbG9ja0Jsb3QuYmxvdE5hbWUpIDogdmFsdWUgJiYgKG5hbWUgIT09IHRoaXMuc3RhdGljcy5ibG90TmFtZSB8fCB0aGlzLmZvcm1hdHMoKVtuYW1lXSAhPT0gdmFsdWUpICYmIHRoaXMucmVwbGFjZVdpdGgobmFtZSwgdmFsdWUpKTtcbiAgfVxuICBmb3JtYXRzKCkge1xuICAgIGNvbnN0IGZvcm1hdHMgPSB0aGlzLmF0dHJpYnV0ZXMudmFsdWVzKCksIGZvcm1hdCA9IHRoaXMuc3RhdGljcy5mb3JtYXRzKHRoaXMuZG9tTm9kZSwgdGhpcy5zY3JvbGwpO1xuICAgIHJldHVybiBmb3JtYXQgIT0gbnVsbCAmJiAoZm9ybWF0c1t0aGlzLnN0YXRpY3MuYmxvdE5hbWVdID0gZm9ybWF0KSwgZm9ybWF0cztcbiAgfVxuICBmb3JtYXRBdChpbmRleCwgbGVuZ3RoLCBuYW1lLCB2YWx1ZSkge1xuICAgIHRoaXMuc2Nyb2xsLnF1ZXJ5KG5hbWUsIFNjb3BlLkJMT0NLKSAhPSBudWxsID8gdGhpcy5mb3JtYXQobmFtZSwgdmFsdWUpIDogc3VwZXIuZm9ybWF0QXQoaW5kZXgsIGxlbmd0aCwgbmFtZSwgdmFsdWUpO1xuICB9XG4gIGluc2VydEF0KGluZGV4LCB2YWx1ZSwgZGVmKSB7XG4gICAgaWYgKGRlZiA9PSBudWxsIHx8IHRoaXMuc2Nyb2xsLnF1ZXJ5KHZhbHVlLCBTY29wZS5JTkxJTkUpICE9IG51bGwpXG4gICAgICBzdXBlci5pbnNlcnRBdChpbmRleCwgdmFsdWUsIGRlZik7XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCBhZnRlciA9IHRoaXMuc3BsaXQoaW5kZXgpO1xuICAgICAgaWYgKGFmdGVyICE9IG51bGwpIHtcbiAgICAgICAgY29uc3QgYmxvdCA9IHRoaXMuc2Nyb2xsLmNyZWF0ZSh2YWx1ZSwgZGVmKTtcbiAgICAgICAgYWZ0ZXIucGFyZW50Lmluc2VydEJlZm9yZShibG90LCBhZnRlcik7XG4gICAgICB9IGVsc2VcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXR0ZW1wdCB0byBpbnNlcnRBdCBhZnRlciBibG9jayBib3VuZGFyaWVzXCIpO1xuICAgIH1cbiAgfVxuICByZXBsYWNlV2l0aChuYW1lLCB2YWx1ZSkge1xuICAgIGNvbnN0IHJlcGxhY2VtZW50ID0gc3VwZXIucmVwbGFjZVdpdGgobmFtZSwgdmFsdWUpO1xuICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZXMuY29weShyZXBsYWNlbWVudCksIHJlcGxhY2VtZW50O1xuICB9XG4gIHVwZGF0ZShtdXRhdGlvbnMsIGNvbnRleHQpIHtcbiAgICBzdXBlci51cGRhdGUobXV0YXRpb25zLCBjb250ZXh0KSwgbXV0YXRpb25zLnNvbWUoXG4gICAgICAobXV0YXRpb24pID0+IG11dGF0aW9uLnRhcmdldCA9PT0gdGhpcy5kb21Ob2RlICYmIG11dGF0aW9uLnR5cGUgPT09IFwiYXR0cmlidXRlc1wiXG4gICAgKSAmJiB0aGlzLmF0dHJpYnV0ZXMuYnVpbGQoKTtcbiAgfVxufTtcbl9CbG9ja0Jsb3QuYmxvdE5hbWUgPSBcImJsb2NrXCIsIF9CbG9ja0Jsb3Quc2NvcGUgPSBTY29wZS5CTE9DS19CTE9ULCBfQmxvY2tCbG90LnRhZ05hbWUgPSBcIlBcIiwgX0Jsb2NrQmxvdC5hbGxvd2VkQ2hpbGRyZW4gPSBbXG4gIElubGluZUJsb3QkMSxcbiAgX0Jsb2NrQmxvdCxcbiAgTGVhZkJsb3QkMVxuXTtcbmxldCBCbG9ja0Jsb3QgPSBfQmxvY2tCbG90O1xuY29uc3QgQmxvY2tCbG90JDEgPSBCbG9ja0Jsb3QsIF9Db250YWluZXJCbG90ID0gY2xhc3MgX0NvbnRhaW5lckJsb3QgZXh0ZW5kcyBQYXJlbnRCbG90JDEge1xuICBjaGVja01lcmdlKCkge1xuICAgIHJldHVybiB0aGlzLm5leHQgIT09IG51bGwgJiYgdGhpcy5uZXh0LnN0YXRpY3MuYmxvdE5hbWUgPT09IHRoaXMuc3RhdGljcy5ibG90TmFtZTtcbiAgfVxuICBkZWxldGVBdChpbmRleCwgbGVuZ3RoKSB7XG4gICAgc3VwZXIuZGVsZXRlQXQoaW5kZXgsIGxlbmd0aCksIHRoaXMuZW5mb3JjZUFsbG93ZWRDaGlsZHJlbigpO1xuICB9XG4gIGZvcm1hdEF0KGluZGV4LCBsZW5ndGgsIG5hbWUsIHZhbHVlKSB7XG4gICAgc3VwZXIuZm9ybWF0QXQoaW5kZXgsIGxlbmd0aCwgbmFtZSwgdmFsdWUpLCB0aGlzLmVuZm9yY2VBbGxvd2VkQ2hpbGRyZW4oKTtcbiAgfVxuICBpbnNlcnRBdChpbmRleCwgdmFsdWUsIGRlZikge1xuICAgIHN1cGVyLmluc2VydEF0KGluZGV4LCB2YWx1ZSwgZGVmKSwgdGhpcy5lbmZvcmNlQWxsb3dlZENoaWxkcmVuKCk7XG4gIH1cbiAgb3B0aW1pemUoY29udGV4dCkge1xuICAgIHN1cGVyLm9wdGltaXplKGNvbnRleHQpLCB0aGlzLmNoaWxkcmVuLmxlbmd0aCA+IDAgJiYgdGhpcy5uZXh0ICE9IG51bGwgJiYgdGhpcy5jaGVja01lcmdlKCkgJiYgKHRoaXMubmV4dC5tb3ZlQ2hpbGRyZW4odGhpcyksIHRoaXMubmV4dC5yZW1vdmUoKSk7XG4gIH1cbn07XG5fQ29udGFpbmVyQmxvdC5ibG90TmFtZSA9IFwiY29udGFpbmVyXCIsIF9Db250YWluZXJCbG90LnNjb3BlID0gU2NvcGUuQkxPQ0tfQkxPVDtcbmxldCBDb250YWluZXJCbG90ID0gX0NvbnRhaW5lckJsb3Q7XG5jb25zdCBDb250YWluZXJCbG90JDEgPSBDb250YWluZXJCbG90O1xuY2xhc3MgRW1iZWRCbG90IGV4dGVuZHMgTGVhZkJsb3QkMSB7XG4gIHN0YXRpYyBmb3JtYXRzKF9kb21Ob2RlLCBfc2Nyb2xsKSB7XG4gIH1cbiAgZm9ybWF0KG5hbWUsIHZhbHVlKSB7XG4gICAgc3VwZXIuZm9ybWF0QXQoMCwgdGhpcy5sZW5ndGgoKSwgbmFtZSwgdmFsdWUpO1xuICB9XG4gIGZvcm1hdEF0KGluZGV4LCBsZW5ndGgsIG5hbWUsIHZhbHVlKSB7XG4gICAgaW5kZXggPT09IDAgJiYgbGVuZ3RoID09PSB0aGlzLmxlbmd0aCgpID8gdGhpcy5mb3JtYXQobmFtZSwgdmFsdWUpIDogc3VwZXIuZm9ybWF0QXQoaW5kZXgsIGxlbmd0aCwgbmFtZSwgdmFsdWUpO1xuICB9XG4gIGZvcm1hdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGljcy5mb3JtYXRzKHRoaXMuZG9tTm9kZSwgdGhpcy5zY3JvbGwpO1xuICB9XG59XG5jb25zdCBFbWJlZEJsb3QkMSA9IEVtYmVkQmxvdCwgT0JTRVJWRVJfQ09ORklHID0ge1xuICBhdHRyaWJ1dGVzOiAhMCxcbiAgY2hhcmFjdGVyRGF0YTogITAsXG4gIGNoYXJhY3RlckRhdGFPbGRWYWx1ZTogITAsXG4gIGNoaWxkTGlzdDogITAsXG4gIHN1YnRyZWU6ICEwXG59LCBNQVhfT1BUSU1JWkVfSVRFUkFUSU9OUyA9IDEwMCwgX1Njcm9sbEJsb3QgPSBjbGFzcyBfU2Nyb2xsQmxvdCBleHRlbmRzIFBhcmVudEJsb3QkMSB7XG4gIGNvbnN0cnVjdG9yKHJlZ2lzdHJ5LCBub2RlKSB7XG4gICAgc3VwZXIobnVsbCwgbm9kZSksIHRoaXMucmVnaXN0cnkgPSByZWdpc3RyeSwgdGhpcy5zY3JvbGwgPSB0aGlzLCB0aGlzLmJ1aWxkKCksIHRoaXMub2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcigobXV0YXRpb25zKSA9PiB7XG4gICAgICB0aGlzLnVwZGF0ZShtdXRhdGlvbnMpO1xuICAgIH0pLCB0aGlzLm9ic2VydmVyLm9ic2VydmUodGhpcy5kb21Ob2RlLCBPQlNFUlZFUl9DT05GSUcpLCB0aGlzLmF0dGFjaCgpO1xuICB9XG4gIGNyZWF0ZShpbnB1dCwgdmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5yZWdpc3RyeS5jcmVhdGUodGhpcywgaW5wdXQsIHZhbHVlKTtcbiAgfVxuICBmaW5kKG5vZGUsIGJ1YmJsZSA9ICExKSB7XG4gICAgY29uc3QgYmxvdCA9IHRoaXMucmVnaXN0cnkuZmluZChub2RlLCBidWJibGUpO1xuICAgIHJldHVybiBibG90ID8gYmxvdC5zY3JvbGwgPT09IHRoaXMgPyBibG90IDogYnViYmxlID8gdGhpcy5maW5kKGJsb3Quc2Nyb2xsLmRvbU5vZGUucGFyZW50Tm9kZSwgITApIDogbnVsbCA6IG51bGw7XG4gIH1cbiAgcXVlcnkocXVlcnksIHNjb3BlID0gU2NvcGUuQU5ZKSB7XG4gICAgcmV0dXJuIHRoaXMucmVnaXN0cnkucXVlcnkocXVlcnksIHNjb3BlKTtcbiAgfVxuICByZWdpc3RlciguLi5kZWZpbml0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnJlZ2lzdHJ5LnJlZ2lzdGVyKC4uLmRlZmluaXRpb25zKTtcbiAgfVxuICBidWlsZCgpIHtcbiAgICB0aGlzLnNjcm9sbCAhPSBudWxsICYmIHN1cGVyLmJ1aWxkKCk7XG4gIH1cbiAgZGV0YWNoKCkge1xuICAgIHN1cGVyLmRldGFjaCgpLCB0aGlzLm9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgfVxuICBkZWxldGVBdChpbmRleCwgbGVuZ3RoKSB7XG4gICAgdGhpcy51cGRhdGUoKSwgaW5kZXggPT09IDAgJiYgbGVuZ3RoID09PSB0aGlzLmxlbmd0aCgpID8gdGhpcy5jaGlsZHJlbi5mb3JFYWNoKChjaGlsZCkgPT4ge1xuICAgICAgY2hpbGQucmVtb3ZlKCk7XG4gICAgfSkgOiBzdXBlci5kZWxldGVBdChpbmRleCwgbGVuZ3RoKTtcbiAgfVxuICBmb3JtYXRBdChpbmRleCwgbGVuZ3RoLCBuYW1lLCB2YWx1ZSkge1xuICAgIHRoaXMudXBkYXRlKCksIHN1cGVyLmZvcm1hdEF0KGluZGV4LCBsZW5ndGgsIG5hbWUsIHZhbHVlKTtcbiAgfVxuICBpbnNlcnRBdChpbmRleCwgdmFsdWUsIGRlZikge1xuICAgIHRoaXMudXBkYXRlKCksIHN1cGVyLmluc2VydEF0KGluZGV4LCB2YWx1ZSwgZGVmKTtcbiAgfVxuICBvcHRpbWl6ZShtdXRhdGlvbnMgPSBbXSwgY29udGV4dCA9IHt9KSB7XG4gICAgc3VwZXIub3B0aW1pemUoY29udGV4dCk7XG4gICAgY29uc3QgbXV0YXRpb25zTWFwID0gY29udGV4dC5tdXRhdGlvbnNNYXAgfHwgLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gICAgbGV0IHJlY29yZHMgPSBBcnJheS5mcm9tKHRoaXMub2JzZXJ2ZXIudGFrZVJlY29yZHMoKSk7XG4gICAgZm9yICg7IHJlY29yZHMubGVuZ3RoID4gMDsgKVxuICAgICAgbXV0YXRpb25zLnB1c2gocmVjb3Jkcy5wb3AoKSk7XG4gICAgY29uc3QgbWFyayA9IChibG90LCBtYXJrUGFyZW50ID0gITApID0+IHtcbiAgICAgIGJsb3QgPT0gbnVsbCB8fCBibG90ID09PSB0aGlzIHx8IGJsb3QuZG9tTm9kZS5wYXJlbnROb2RlICE9IG51bGwgJiYgKG11dGF0aW9uc01hcC5oYXMoYmxvdC5kb21Ob2RlKSB8fCBtdXRhdGlvbnNNYXAuc2V0KGJsb3QuZG9tTm9kZSwgW10pLCBtYXJrUGFyZW50ICYmIG1hcmsoYmxvdC5wYXJlbnQpKTtcbiAgICB9LCBvcHRpbWl6ZSA9IChibG90KSA9PiB7XG4gICAgICBtdXRhdGlvbnNNYXAuaGFzKGJsb3QuZG9tTm9kZSkgJiYgKGJsb3QgaW5zdGFuY2VvZiBQYXJlbnRCbG90JDEgJiYgYmxvdC5jaGlsZHJlbi5mb3JFYWNoKG9wdGltaXplKSwgbXV0YXRpb25zTWFwLmRlbGV0ZShibG90LmRvbU5vZGUpLCBibG90Lm9wdGltaXplKGNvbnRleHQpKTtcbiAgICB9O1xuICAgIGxldCByZW1haW5pbmcgPSBtdXRhdGlvbnM7XG4gICAgZm9yIChsZXQgaSA9IDA7IHJlbWFpbmluZy5sZW5ndGggPiAwOyBpICs9IDEpIHtcbiAgICAgIGlmIChpID49IE1BWF9PUFRJTUlaRV9JVEVSQVRJT05TKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJbUGFyY2htZW50XSBNYXhpbXVtIG9wdGltaXplIGl0ZXJhdGlvbnMgcmVhY2hlZFwiKTtcbiAgICAgIGZvciAocmVtYWluaW5nLmZvckVhY2goKG11dGF0aW9uKSA9PiB7XG4gICAgICAgIGNvbnN0IGJsb3QgPSB0aGlzLmZpbmQobXV0YXRpb24udGFyZ2V0LCAhMCk7XG4gICAgICAgIGJsb3QgIT0gbnVsbCAmJiAoYmxvdC5kb21Ob2RlID09PSBtdXRhdGlvbi50YXJnZXQgJiYgKG11dGF0aW9uLnR5cGUgPT09IFwiY2hpbGRMaXN0XCIgPyAobWFyayh0aGlzLmZpbmQobXV0YXRpb24ucHJldmlvdXNTaWJsaW5nLCAhMSkpLCBBcnJheS5mcm9tKG11dGF0aW9uLmFkZGVkTm9kZXMpLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgICAgICBjb25zdCBjaGlsZCA9IHRoaXMuZmluZChub2RlLCAhMSk7XG4gICAgICAgICAgbWFyayhjaGlsZCwgITEpLCBjaGlsZCBpbnN0YW5jZW9mIFBhcmVudEJsb3QkMSAmJiBjaGlsZC5jaGlsZHJlbi5mb3JFYWNoKChncmFuZENoaWxkKSA9PiB7XG4gICAgICAgICAgICBtYXJrKGdyYW5kQ2hpbGQsICExKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSkpIDogbXV0YXRpb24udHlwZSA9PT0gXCJhdHRyaWJ1dGVzXCIgJiYgbWFyayhibG90LnByZXYpKSwgbWFyayhibG90KSk7XG4gICAgICB9KSwgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKG9wdGltaXplKSwgcmVtYWluaW5nID0gQXJyYXkuZnJvbSh0aGlzLm9ic2VydmVyLnRha2VSZWNvcmRzKCkpLCByZWNvcmRzID0gcmVtYWluaW5nLnNsaWNlKCk7IHJlY29yZHMubGVuZ3RoID4gMDsgKVxuICAgICAgICBtdXRhdGlvbnMucHVzaChyZWNvcmRzLnBvcCgpKTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlKG11dGF0aW9ucywgY29udGV4dCA9IHt9KSB7XG4gICAgbXV0YXRpb25zID0gbXV0YXRpb25zIHx8IHRoaXMub2JzZXJ2ZXIudGFrZVJlY29yZHMoKTtcbiAgICBjb25zdCBtdXRhdGlvbnNNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbiAgICBtdXRhdGlvbnMubWFwKChtdXRhdGlvbikgPT4ge1xuICAgICAgY29uc3QgYmxvdCA9IHRoaXMuZmluZChtdXRhdGlvbi50YXJnZXQsICEwKTtcbiAgICAgIHJldHVybiBibG90ID09IG51bGwgPyBudWxsIDogbXV0YXRpb25zTWFwLmhhcyhibG90LmRvbU5vZGUpID8gKG11dGF0aW9uc01hcC5nZXQoYmxvdC5kb21Ob2RlKS5wdXNoKG11dGF0aW9uKSwgbnVsbCkgOiAobXV0YXRpb25zTWFwLnNldChibG90LmRvbU5vZGUsIFttdXRhdGlvbl0pLCBibG90KTtcbiAgICB9KS5mb3JFYWNoKChibG90KSA9PiB7XG4gICAgICBibG90ICE9IG51bGwgJiYgYmxvdCAhPT0gdGhpcyAmJiBtdXRhdGlvbnNNYXAuaGFzKGJsb3QuZG9tTm9kZSkgJiYgYmxvdC51cGRhdGUobXV0YXRpb25zTWFwLmdldChibG90LmRvbU5vZGUpIHx8IFtdLCBjb250ZXh0KTtcbiAgICB9KSwgY29udGV4dC5tdXRhdGlvbnNNYXAgPSBtdXRhdGlvbnNNYXAsIG11dGF0aW9uc01hcC5oYXModGhpcy5kb21Ob2RlKSAmJiBzdXBlci51cGRhdGUobXV0YXRpb25zTWFwLmdldCh0aGlzLmRvbU5vZGUpLCBjb250ZXh0KSwgdGhpcy5vcHRpbWl6ZShtdXRhdGlvbnMsIGNvbnRleHQpO1xuICB9XG59O1xuX1Njcm9sbEJsb3QuYmxvdE5hbWUgPSBcInNjcm9sbFwiLCBfU2Nyb2xsQmxvdC5kZWZhdWx0Q2hpbGQgPSBCbG9ja0Jsb3QkMSwgX1Njcm9sbEJsb3QuYWxsb3dlZENoaWxkcmVuID0gW0Jsb2NrQmxvdCQxLCBDb250YWluZXJCbG90JDFdLCBfU2Nyb2xsQmxvdC5zY29wZSA9IFNjb3BlLkJMT0NLX0JMT1QsIF9TY3JvbGxCbG90LnRhZ05hbWUgPSBcIkRJVlwiO1xubGV0IFNjcm9sbEJsb3QgPSBfU2Nyb2xsQmxvdDtcbmNvbnN0IFNjcm9sbEJsb3QkMSA9IFNjcm9sbEJsb3QsIF9UZXh0QmxvdCA9IGNsYXNzIF9UZXh0QmxvdCBleHRlbmRzIExlYWZCbG90JDEge1xuICBzdGF0aWMgY3JlYXRlKHZhbHVlKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHZhbHVlKTtcbiAgfVxuICBzdGF0aWMgdmFsdWUoZG9tTm9kZSkge1xuICAgIHJldHVybiBkb21Ob2RlLmRhdGE7XG4gIH1cbiAgY29uc3RydWN0b3Ioc2Nyb2xsLCBub2RlKSB7XG4gICAgc3VwZXIoc2Nyb2xsLCBub2RlKSwgdGhpcy50ZXh0ID0gdGhpcy5zdGF0aWNzLnZhbHVlKHRoaXMuZG9tTm9kZSk7XG4gIH1cbiAgZGVsZXRlQXQoaW5kZXgsIGxlbmd0aCkge1xuICAgIHRoaXMuZG9tTm9kZS5kYXRhID0gdGhpcy50ZXh0ID0gdGhpcy50ZXh0LnNsaWNlKDAsIGluZGV4KSArIHRoaXMudGV4dC5zbGljZShpbmRleCArIGxlbmd0aCk7XG4gIH1cbiAgaW5kZXgobm9kZSwgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIHRoaXMuZG9tTm9kZSA9PT0gbm9kZSA/IG9mZnNldCA6IC0xO1xuICB9XG4gIGluc2VydEF0KGluZGV4LCB2YWx1ZSwgZGVmKSB7XG4gICAgZGVmID09IG51bGwgPyAodGhpcy50ZXh0ID0gdGhpcy50ZXh0LnNsaWNlKDAsIGluZGV4KSArIHZhbHVlICsgdGhpcy50ZXh0LnNsaWNlKGluZGV4KSwgdGhpcy5kb21Ob2RlLmRhdGEgPSB0aGlzLnRleHQpIDogc3VwZXIuaW5zZXJ0QXQoaW5kZXgsIHZhbHVlLCBkZWYpO1xuICB9XG4gIGxlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy50ZXh0Lmxlbmd0aDtcbiAgfVxuICBvcHRpbWl6ZShjb250ZXh0KSB7XG4gICAgc3VwZXIub3B0aW1pemUoY29udGV4dCksIHRoaXMudGV4dCA9IHRoaXMuc3RhdGljcy52YWx1ZSh0aGlzLmRvbU5vZGUpLCB0aGlzLnRleHQubGVuZ3RoID09PSAwID8gdGhpcy5yZW1vdmUoKSA6IHRoaXMubmV4dCBpbnN0YW5jZW9mIF9UZXh0QmxvdCAmJiB0aGlzLm5leHQucHJldiA9PT0gdGhpcyAmJiAodGhpcy5pbnNlcnRBdCh0aGlzLmxlbmd0aCgpLCB0aGlzLm5leHQudmFsdWUoKSksIHRoaXMubmV4dC5yZW1vdmUoKSk7XG4gIH1cbiAgcG9zaXRpb24oaW5kZXgsIF9pbmNsdXNpdmUgPSAhMSkge1xuICAgIHJldHVybiBbdGhpcy5kb21Ob2RlLCBpbmRleF07XG4gIH1cbiAgc3BsaXQoaW5kZXgsIGZvcmNlID0gITEpIHtcbiAgICBpZiAoIWZvcmNlKSB7XG4gICAgICBpZiAoaW5kZXggPT09IDApXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgaWYgKGluZGV4ID09PSB0aGlzLmxlbmd0aCgpKVxuICAgICAgICByZXR1cm4gdGhpcy5uZXh0O1xuICAgIH1cbiAgICBjb25zdCBhZnRlciA9IHRoaXMuc2Nyb2xsLmNyZWF0ZSh0aGlzLmRvbU5vZGUuc3BsaXRUZXh0KGluZGV4KSk7XG4gICAgcmV0dXJuIHRoaXMucGFyZW50Lmluc2VydEJlZm9yZShhZnRlciwgdGhpcy5uZXh0IHx8IHZvaWQgMCksIHRoaXMudGV4dCA9IHRoaXMuc3RhdGljcy52YWx1ZSh0aGlzLmRvbU5vZGUpLCBhZnRlcjtcbiAgfVxuICB1cGRhdGUobXV0YXRpb25zLCBfY29udGV4dCkge1xuICAgIG11dGF0aW9ucy5zb21lKChtdXRhdGlvbikgPT4gbXV0YXRpb24udHlwZSA9PT0gXCJjaGFyYWN0ZXJEYXRhXCIgJiYgbXV0YXRpb24udGFyZ2V0ID09PSB0aGlzLmRvbU5vZGUpICYmICh0aGlzLnRleHQgPSB0aGlzLnN0YXRpY3MudmFsdWUodGhpcy5kb21Ob2RlKSk7XG4gIH1cbiAgdmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMudGV4dDtcbiAgfVxufTtcbl9UZXh0QmxvdC5ibG90TmFtZSA9IFwidGV4dFwiLCBfVGV4dEJsb3Quc2NvcGUgPSBTY29wZS5JTkxJTkVfQkxPVDtcbmxldCBUZXh0QmxvdCA9IF9UZXh0QmxvdDtcbmNvbnN0IFRleHRCbG90JDEgPSBUZXh0QmxvdDtcbmV4cG9ydCB7XG4gIEF0dHJpYnV0b3IsXG4gIEF0dHJpYnV0b3JTdG9yZSQxIGFzIEF0dHJpYnV0b3JTdG9yZSxcbiAgQmxvY2tCbG90JDEgYXMgQmxvY2tCbG90LFxuICBDbGFzc0F0dHJpYnV0b3IkMSBhcyBDbGFzc0F0dHJpYnV0b3IsXG4gIENvbnRhaW5lckJsb3QkMSBhcyBDb250YWluZXJCbG90LFxuICBFbWJlZEJsb3QkMSBhcyBFbWJlZEJsb3QsXG4gIElubGluZUJsb3QkMSBhcyBJbmxpbmVCbG90LFxuICBMZWFmQmxvdCQxIGFzIExlYWZCbG90LFxuICBQYXJlbnRCbG90JDEgYXMgUGFyZW50QmxvdCxcbiAgUmVnaXN0cnksXG4gIFNjb3BlLFxuICBTY3JvbGxCbG90JDEgYXMgU2Nyb2xsQmxvdCxcbiAgU3R5bGVBdHRyaWJ1dG9yJDEgYXMgU3R5bGVBdHRyaWJ1dG9yLFxuICBUZXh0QmxvdCQxIGFzIFRleHRCbG90XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFyY2htZW50LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/parchment/dist/parchment.js\n");

/***/ })

};
;
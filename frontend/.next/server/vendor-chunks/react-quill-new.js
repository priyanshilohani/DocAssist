"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-quill-new";
exports.ids = ["vendor-chunks/react-quill-new"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-quill-new/lib/index.js":
/*!***************************************************!*\
  !*** ./node_modules/react-quill-new/lib/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Quill: () => (/* reexport safe */ quill__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/isEqual.js */ \"(ssr)/./node_modules/lodash/isEqual.js\");\n/* harmony import */ var quill__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! quill */ \"(ssr)/./node_modules/quill/quill.js\");\n/*\nReact-Quill\nhttps://github.com/zenoamaro/react-quill\n*/\n\n\n\n\nclass ReactQuill extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n    constructor(props) {\n        super(props);\n        this.editingAreaRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.createRef)();\n        /*\n        Changing one of these props should cause a full re-render and a\n        re-instantiation of the Quill editor.\n        */\n        this.dirtyProps = [\n            'modules',\n            'formats',\n            'bounds',\n            'theme',\n            'children',\n        ];\n        /*\n        Changing one of these props should cause a regular update. These are mostly\n        props that act on the container, rather than the quillized editing area.\n        */\n        this.cleanProps = [\n            'id',\n            'className',\n            'style',\n            'placeholder',\n            'tabIndex',\n            'onChange',\n            'onChangeSelection',\n            'onFocus',\n            'onBlur',\n            'onKeyPress',\n            'onKeyDown',\n            'onKeyUp',\n        ];\n        this.state = {\n            generation: 0,\n        };\n        /*\n        Tracks the internal selection of the Quill editor\n        */\n        this.selection = null;\n        this.onEditorChange = (eventName, rangeOrDelta, oldRangeOrDelta, source) => {\n            if (eventName === 'text-change') {\n                this.onEditorChangeText?.(this.editor.root.innerHTML, rangeOrDelta, source, this.unprivilegedEditor);\n            }\n            else if (eventName === 'selection-change') {\n                this.onEditorChangeSelection?.(rangeOrDelta, source, this.unprivilegedEditor);\n            }\n        };\n        const value = this.isControlled() ? props.value : props.defaultValue;\n        this.value = value ?? '';\n    }\n    validateProps(props) {\n        if (react__WEBPACK_IMPORTED_MODULE_0__.Children.count(props.children) > 1)\n            throw new Error('The Quill editing area can only be composed of a single React element.');\n        if (react__WEBPACK_IMPORTED_MODULE_0__.Children.count(props.children)) {\n            const child = react__WEBPACK_IMPORTED_MODULE_0__.Children.only(props.children);\n            if (child?.type === 'textarea')\n                throw new Error('Quill does not support editing on a <textarea>. Use a <div> instead.');\n        }\n        if (this.lastDeltaChangeSet &&\n            props.value === this.lastDeltaChangeSet)\n            throw new Error('You are passing the `delta` object from the `onChange` event back ' +\n                'as `value`. You most probably want `editor.getContents()` instead. ' +\n                'See: https://github.com/zenoamaro/react-quill#using-deltas');\n    }\n    shouldComponentUpdate(nextProps, nextState) {\n        this.validateProps(nextProps);\n        // If the editor hasn't been instantiated yet, or the component has been\n        // regenerated, we already know we should update.\n        if (!this.editor || this.state.generation !== nextState.generation) {\n            return true;\n        }\n        // Handle value changes in-place\n        if ('value' in nextProps) {\n            const prevContents = this.getEditorContents();\n            const nextContents = nextProps.value ?? '';\n            // NOTE: Seeing that Quill is missing a way to prevent edits, we have to\n            //       settle for a hybrid between controlled and uncontrolled mode. We\n            //       can't prevent the change, but we'll still override content\n            //       whenever `value` differs from current state.\n            // NOTE: Comparing an HTML string and a Quill Delta will always trigger a\n            //       change, regardless of whether they represent the same document.\n            if (!this.isEqualValue(nextContents, prevContents)) {\n                this.setEditorContents(this.editor, nextContents);\n            }\n        }\n        // Handle read-only changes in-place\n        if (nextProps.readOnly !== this.props.readOnly) {\n            this.setEditorReadOnly(this.editor, nextProps.readOnly);\n        }\n        // Clean and Dirty props require a render\n        return [...this.cleanProps, ...this.dirtyProps].some((prop) => {\n            return !lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_1__(nextProps[prop], this.props[prop]);\n        });\n    }\n    shouldComponentRegenerate(nextProps) {\n        // Whenever a `dirtyProp` changes, the editor needs reinstantiation.\n        return this.dirtyProps.some((prop) => {\n            return !lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_1__(nextProps[prop], this.props[prop]);\n        });\n    }\n    componentDidMount() {\n        this.instantiateEditor();\n        this.setEditorContents(this.editor, this.getEditorContents());\n    }\n    componentWillUnmount() {\n        this.destroyEditor();\n    }\n    componentDidUpdate(prevProps, prevState) {\n        // If we're changing one of the `dirtyProps`, the entire Quill Editor needs\n        // to be re-instantiated. Regenerating the editor will cause the whole tree,\n        // including the container, to be cleaned up and re-rendered from scratch.\n        // Store the contents so they can be restored later.\n        if (this.editor && this.shouldComponentRegenerate(prevProps)) {\n            const delta = this.editor.getContents();\n            const selection = this.editor.getSelection();\n            this.regenerationSnapshot = { delta, selection };\n            this.setState({ generation: this.state.generation + 1 });\n            this.destroyEditor();\n        }\n        // The component has been regenerated, so it must be re-instantiated, and\n        // its content must be restored to the previous values from the snapshot.\n        if (this.state.generation !== prevState.generation) {\n            const { delta, selection } = this.regenerationSnapshot;\n            delete this.regenerationSnapshot;\n            this.instantiateEditor();\n            const editor = this.editor;\n            editor.setContents(delta);\n            postpone(() => this.setEditorSelection(editor, selection));\n        }\n    }\n    instantiateEditor() {\n        if (this.editor) {\n            this.hookEditor(this.editor);\n        }\n        else {\n            this.editor = this.createEditor(this.getEditingArea(), this.getEditorConfig());\n        }\n    }\n    destroyEditor() {\n        if (!this.editor)\n            return;\n        this.unhookEditor(this.editor);\n    }\n    /*\n    We consider the component to be controlled if `value` is being sent in props.\n    */\n    isControlled() {\n        return 'value' in this.props;\n    }\n    getEditorConfig() {\n        return {\n            bounds: this.props.bounds,\n            formats: this.props.formats,\n            modules: this.props.modules,\n            placeholder: this.props.placeholder,\n            readOnly: this.props.readOnly,\n            tabIndex: this.props.tabIndex,\n            theme: this.props.theme,\n        };\n    }\n    getEditor() {\n        if (!this.editor)\n            throw new Error('Accessing non-instantiated editor');\n        return this.editor;\n    }\n    /**\n    Creates an editor on the given element. The editor will be passed the\n    configuration, have its events bound,\n    */\n    createEditor(element, config) {\n        const editor = new quill__WEBPACK_IMPORTED_MODULE_2__[\"default\"](element, config);\n        if (config.tabIndex != null) {\n            this.setEditorTabIndex(editor, config.tabIndex);\n        }\n        this.hookEditor(editor);\n        return editor;\n    }\n    hookEditor(editor) {\n        // Expose the editor on change events via a weaker, unprivileged proxy\n        // object that does not allow accidentally modifying editor state.\n        this.unprivilegedEditor = this.makeUnprivilegedEditor(editor);\n        // Using `editor-change` allows picking up silent updates, like selection\n        // changes on typing.\n        editor.on('editor-change', this.onEditorChange);\n    }\n    unhookEditor(editor) {\n        editor.off('editor-change', this.onEditorChange);\n    }\n    getEditorContents() {\n        return this.value;\n    }\n    getEditorSelection() {\n        return this.selection;\n    }\n    /*\n    True if the value is a Delta instance or a Delta look-alike.\n    */\n    isDelta(value) {\n        return value && value.ops;\n    }\n    /*\n    Special comparison function that knows how to compare Deltas.\n    */\n    isEqualValue(value, nextValue) {\n        if (this.isDelta(value) && this.isDelta(nextValue)) {\n            return lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_1__(value.ops, nextValue.ops);\n        }\n        else {\n            return lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_1__(value, nextValue);\n        }\n    }\n    /*\n    Replace the contents of the editor, but keep the previous selection hanging\n    around so that the cursor won't move.\n    */\n    setEditorContents(editor, value) {\n        this.value = value;\n        const sel = this.getEditorSelection();\n        if (typeof value === 'string') {\n            editor.setContents(editor.clipboard.convert({ html: value }));\n        }\n        else {\n            editor.setContents(value);\n        }\n        postpone(() => this.setEditorSelection(editor, sel));\n    }\n    setEditorSelection(editor, range) {\n        this.selection = range;\n        if (range) {\n            // Validate bounds before applying.\n            const length = editor.getLength();\n            range.index = Math.max(0, Math.min(range.index, length - 1));\n            range.length = Math.max(0, Math.min(range.length, (length - 1) - range.index));\n            editor.setSelection(range);\n        }\n    }\n    setEditorTabIndex(editor, tabIndex) {\n        if (editor?.scroll?.domNode) {\n            editor.scroll.domNode.tabIndex = tabIndex;\n        }\n    }\n    setEditorReadOnly(editor, value) {\n        if (value) {\n            editor.disable();\n        }\n        else {\n            editor.enable();\n        }\n    }\n    /*\n    Returns a weaker, unprivileged proxy object that only exposes read-only\n    accessors found on the editor instance, without any state-modifying methods.\n    */\n    makeUnprivilegedEditor(editor) {\n        const e = editor;\n        return {\n            getHTML: () => e.root.innerHTML,\n            getSemanticHTML: e.getSemanticHTML.bind(e),\n            getLength: e.getLength.bind(e),\n            getText: e.getText.bind(e),\n            getContents: e.getContents.bind(e),\n            getSelection: e.getSelection.bind(e),\n            getBounds: e.getBounds.bind(e),\n        };\n    }\n    getEditingArea() {\n        const element = this.editingAreaRef.current;\n        if (!element) {\n            throw new Error('Cannot find element for editing area');\n        }\n        if (element.nodeType === 3) {\n            throw new Error('Editing area cannot be a text node');\n        }\n        return element;\n    }\n    /*\n    Renders an editor area, unless it has been provided one to clone.\n    */\n    renderEditingArea() {\n        const { children, preserveWhitespace } = this.props;\n        const { generation } = this.state;\n        const properties = {\n            key: generation,\n            ref: this.editingAreaRef,\n        };\n        if (react__WEBPACK_IMPORTED_MODULE_0__.Children.count(children)) {\n            return react__WEBPACK_IMPORTED_MODULE_0__.cloneElement(react__WEBPACK_IMPORTED_MODULE_0__.Children.only(children), properties);\n        }\n        return preserveWhitespace ?\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"pre\", { ...properties }) :\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { ...properties });\n    }\n    render() {\n        return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { id: this.props.id, style: this.props.style, key: this.state.generation, className: `quill ${this.props.className ?? ''}`, onKeyPress: this.props.onKeyPress, onKeyDown: this.props.onKeyDown, onKeyUp: this.props.onKeyUp }, this.renderEditingArea()));\n    }\n    onEditorChangeText(value, delta, source, editor) {\n        if (!this.editor)\n            return;\n        // We keep storing the same type of value as what the user gives us,\n        // so that value comparisons will be more stable and predictable.\n        const nextContents = this.isDelta(this.value)\n            ? editor.getContents()\n            : editor.getHTML();\n        if (nextContents !== this.getEditorContents()) {\n            // Taint this `delta` object, so we can recognize whether the user\n            // is trying to send it back as `value`, preventing a likely loop.\n            this.lastDeltaChangeSet = delta;\n            this.value = nextContents;\n            this.props.onChange?.(value, delta, source, editor);\n        }\n    }\n    onEditorChangeSelection(nextSelection, source, editor) {\n        if (!this.editor)\n            return;\n        const currentSelection = this.getEditorSelection();\n        const hasGainedFocus = !currentSelection && nextSelection;\n        const hasLostFocus = currentSelection && !nextSelection;\n        if (lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_1__(nextSelection, currentSelection))\n            return;\n        this.selection = nextSelection;\n        this.props.onChangeSelection?.(nextSelection, source, editor);\n        if (hasGainedFocus) {\n            this.props.onFocus?.(nextSelection, source, editor);\n        }\n        else if (hasLostFocus) {\n            this.props.onBlur?.(currentSelection, source, editor);\n        }\n    }\n    focus() {\n        if (!this.editor)\n            return;\n        this.editor.focus();\n    }\n    blur() {\n        if (!this.editor)\n            return;\n        this.selection = null;\n        this.editor.blur();\n    }\n}\nReactQuill.displayName = 'React Quill';\n/*\nExport Quill to be able to call `register`\n*/\nReactQuill.Quill = quill__WEBPACK_IMPORTED_MODULE_2__[\"default\"];\nReactQuill.defaultProps = {\n    theme: 'snow',\n    modules: {},\n    readOnly: false,\n};\n/*\nSmall helper to execute a function in the next micro-tick.\n*/\nfunction postpone(fn) {\n    Promise.resolve().then(fn);\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ReactQuill);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcXVpbGwtbmV3L2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ3lDO0FBQ0Q7QUFDZDtBQUNUO0FBQ2pCLHlCQUF5Qiw0Q0FBZTtBQUN4QztBQUNBO0FBQ0EsOEJBQThCLGdEQUFTO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMkNBQWM7QUFDMUI7QUFDQSxZQUFZLDJDQUFjO0FBQzFCLDBCQUEwQiwyQ0FBYztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsOENBQU87QUFDM0IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDhDQUFPO0FBQzNCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQyw0QkFBNEIsdUNBQXVDO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsNkNBQUs7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsOENBQU87QUFDMUI7QUFDQTtBQUNBLG1CQUFtQiw4Q0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxhQUFhO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsK0JBQStCO0FBQy9DLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwyQ0FBYztBQUMxQixtQkFBbUIsK0NBQWtCLENBQUMsMkNBQWM7QUFDcEQ7QUFDQTtBQUNBLFlBQVksZ0RBQW1CLFVBQVUsZUFBZTtBQUN4RCxZQUFZLGdEQUFtQixVQUFVLGVBQWU7QUFDeEQ7QUFDQTtBQUNBLGdCQUFnQixnREFBbUIsVUFBVSw0RkFBNEYsMkJBQTJCLG9HQUFvRztBQUN4UTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw4Q0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDZDQUFLO0FBQ3hCO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFlLFVBQVUsRUFBQztBQUMxQiIsInNvdXJjZXMiOlsid2VicGFjazovL2RvY2Fzc2lzdC8uL25vZGVfbW9kdWxlcy9yZWFjdC1xdWlsbC1uZXcvbGliL2luZGV4LmpzPzAxNjkiXSwic291cmNlc0NvbnRlbnQiOlsiLypcblJlYWN0LVF1aWxsXG5odHRwczovL2dpdGh1Yi5jb20vemVub2FtYXJvL3JlYWN0LXF1aWxsXG4qL1xuaW1wb3J0IFJlYWN0LCB7IGNyZWF0ZVJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBpc0VxdWFsIGZyb20gJ2xvZGFzaC9pc0VxdWFsLmpzJztcbmltcG9ydCBRdWlsbCBmcm9tICdxdWlsbCc7XG5leHBvcnQgeyBRdWlsbCB9O1xuY2xhc3MgUmVhY3RRdWlsbCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuICAgICAgICB0aGlzLmVkaXRpbmdBcmVhUmVmID0gY3JlYXRlUmVmKCk7XG4gICAgICAgIC8qXG4gICAgICAgIENoYW5naW5nIG9uZSBvZiB0aGVzZSBwcm9wcyBzaG91bGQgY2F1c2UgYSBmdWxsIHJlLXJlbmRlciBhbmQgYVxuICAgICAgICByZS1pbnN0YW50aWF0aW9uIG9mIHRoZSBRdWlsbCBlZGl0b3IuXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuZGlydHlQcm9wcyA9IFtcbiAgICAgICAgICAgICdtb2R1bGVzJyxcbiAgICAgICAgICAgICdmb3JtYXRzJyxcbiAgICAgICAgICAgICdib3VuZHMnLFxuICAgICAgICAgICAgJ3RoZW1lJyxcbiAgICAgICAgICAgICdjaGlsZHJlbicsXG4gICAgICAgIF07XG4gICAgICAgIC8qXG4gICAgICAgIENoYW5naW5nIG9uZSBvZiB0aGVzZSBwcm9wcyBzaG91bGQgY2F1c2UgYSByZWd1bGFyIHVwZGF0ZS4gVGhlc2UgYXJlIG1vc3RseVxuICAgICAgICBwcm9wcyB0aGF0IGFjdCBvbiB0aGUgY29udGFpbmVyLCByYXRoZXIgdGhhbiB0aGUgcXVpbGxpemVkIGVkaXRpbmcgYXJlYS5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jbGVhblByb3BzID0gW1xuICAgICAgICAgICAgJ2lkJyxcbiAgICAgICAgICAgICdjbGFzc05hbWUnLFxuICAgICAgICAgICAgJ3N0eWxlJyxcbiAgICAgICAgICAgICdwbGFjZWhvbGRlcicsXG4gICAgICAgICAgICAndGFiSW5kZXgnLFxuICAgICAgICAgICAgJ29uQ2hhbmdlJyxcbiAgICAgICAgICAgICdvbkNoYW5nZVNlbGVjdGlvbicsXG4gICAgICAgICAgICAnb25Gb2N1cycsXG4gICAgICAgICAgICAnb25CbHVyJyxcbiAgICAgICAgICAgICdvbktleVByZXNzJyxcbiAgICAgICAgICAgICdvbktleURvd24nLFxuICAgICAgICAgICAgJ29uS2V5VXAnLFxuICAgICAgICBdO1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgZ2VuZXJhdGlvbjogMCxcbiAgICAgICAgfTtcbiAgICAgICAgLypcbiAgICAgICAgVHJhY2tzIHRoZSBpbnRlcm5hbCBzZWxlY3Rpb24gb2YgdGhlIFF1aWxsIGVkaXRvclxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMub25FZGl0b3JDaGFuZ2UgPSAoZXZlbnROYW1lLCByYW5nZU9yRGVsdGEsIG9sZFJhbmdlT3JEZWx0YSwgc291cmNlKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXZlbnROYW1lID09PSAndGV4dC1jaGFuZ2UnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkVkaXRvckNoYW5nZVRleHQ/Lih0aGlzLmVkaXRvci5yb290LmlubmVySFRNTCwgcmFuZ2VPckRlbHRhLCBzb3VyY2UsIHRoaXMudW5wcml2aWxlZ2VkRWRpdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50TmFtZSA9PT0gJ3NlbGVjdGlvbi1jaGFuZ2UnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkVkaXRvckNoYW5nZVNlbGVjdGlvbj8uKHJhbmdlT3JEZWx0YSwgc291cmNlLCB0aGlzLnVucHJpdmlsZWdlZEVkaXRvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5pc0NvbnRyb2xsZWQoKSA/IHByb3BzLnZhbHVlIDogcHJvcHMuZGVmYXVsdFZhbHVlO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWUgPz8gJyc7XG4gICAgfVxuICAgIHZhbGlkYXRlUHJvcHMocHJvcHMpIHtcbiAgICAgICAgaWYgKFJlYWN0LkNoaWxkcmVuLmNvdW50KHByb3BzLmNoaWxkcmVuKSA+IDEpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBRdWlsbCBlZGl0aW5nIGFyZWEgY2FuIG9ubHkgYmUgY29tcG9zZWQgb2YgYSBzaW5nbGUgUmVhY3QgZWxlbWVudC4nKTtcbiAgICAgICAgaWYgKFJlYWN0LkNoaWxkcmVuLmNvdW50KHByb3BzLmNoaWxkcmVuKSkge1xuICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBSZWFjdC5DaGlsZHJlbi5vbmx5KHByb3BzLmNoaWxkcmVuKTtcbiAgICAgICAgICAgIGlmIChjaGlsZD8udHlwZSA9PT0gJ3RleHRhcmVhJylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1F1aWxsIGRvZXMgbm90IHN1cHBvcnQgZWRpdGluZyBvbiBhIDx0ZXh0YXJlYT4uIFVzZSBhIDxkaXY+IGluc3RlYWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubGFzdERlbHRhQ2hhbmdlU2V0ICYmXG4gICAgICAgICAgICBwcm9wcy52YWx1ZSA9PT0gdGhpcy5sYXN0RGVsdGFDaGFuZ2VTZXQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBhcmUgcGFzc2luZyB0aGUgYGRlbHRhYCBvYmplY3QgZnJvbSB0aGUgYG9uQ2hhbmdlYCBldmVudCBiYWNrICcgK1xuICAgICAgICAgICAgICAgICdhcyBgdmFsdWVgLiBZb3UgbW9zdCBwcm9iYWJseSB3YW50IGBlZGl0b3IuZ2V0Q29udGVudHMoKWAgaW5zdGVhZC4gJyArXG4gICAgICAgICAgICAgICAgJ1NlZTogaHR0cHM6Ly9naXRodWIuY29tL3plbm9hbWFyby9yZWFjdC1xdWlsbCN1c2luZy1kZWx0YXMnKTtcbiAgICB9XG4gICAgc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5leHRQcm9wcywgbmV4dFN0YXRlKSB7XG4gICAgICAgIHRoaXMudmFsaWRhdGVQcm9wcyhuZXh0UHJvcHMpO1xuICAgICAgICAvLyBJZiB0aGUgZWRpdG9yIGhhc24ndCBiZWVuIGluc3RhbnRpYXRlZCB5ZXQsIG9yIHRoZSBjb21wb25lbnQgaGFzIGJlZW5cbiAgICAgICAgLy8gcmVnZW5lcmF0ZWQsIHdlIGFscmVhZHkga25vdyB3ZSBzaG91bGQgdXBkYXRlLlxuICAgICAgICBpZiAoIXRoaXMuZWRpdG9yIHx8IHRoaXMuc3RhdGUuZ2VuZXJhdGlvbiAhPT0gbmV4dFN0YXRlLmdlbmVyYXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEhhbmRsZSB2YWx1ZSBjaGFuZ2VzIGluLXBsYWNlXG4gICAgICAgIGlmICgndmFsdWUnIGluIG5leHRQcm9wcykge1xuICAgICAgICAgICAgY29uc3QgcHJldkNvbnRlbnRzID0gdGhpcy5nZXRFZGl0b3JDb250ZW50cygpO1xuICAgICAgICAgICAgY29uc3QgbmV4dENvbnRlbnRzID0gbmV4dFByb3BzLnZhbHVlID8/ICcnO1xuICAgICAgICAgICAgLy8gTk9URTogU2VlaW5nIHRoYXQgUXVpbGwgaXMgbWlzc2luZyBhIHdheSB0byBwcmV2ZW50IGVkaXRzLCB3ZSBoYXZlIHRvXG4gICAgICAgICAgICAvLyAgICAgICBzZXR0bGUgZm9yIGEgaHlicmlkIGJldHdlZW4gY29udHJvbGxlZCBhbmQgdW5jb250cm9sbGVkIG1vZGUuIFdlXG4gICAgICAgICAgICAvLyAgICAgICBjYW4ndCBwcmV2ZW50IHRoZSBjaGFuZ2UsIGJ1dCB3ZSdsbCBzdGlsbCBvdmVycmlkZSBjb250ZW50XG4gICAgICAgICAgICAvLyAgICAgICB3aGVuZXZlciBgdmFsdWVgIGRpZmZlcnMgZnJvbSBjdXJyZW50IHN0YXRlLlxuICAgICAgICAgICAgLy8gTk9URTogQ29tcGFyaW5nIGFuIEhUTUwgc3RyaW5nIGFuZCBhIFF1aWxsIERlbHRhIHdpbGwgYWx3YXlzIHRyaWdnZXIgYVxuICAgICAgICAgICAgLy8gICAgICAgY2hhbmdlLCByZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhleSByZXByZXNlbnQgdGhlIHNhbWUgZG9jdW1lbnQuXG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNFcXVhbFZhbHVlKG5leHRDb250ZW50cywgcHJldkNvbnRlbnRzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0RWRpdG9yQ29udGVudHModGhpcy5lZGl0b3IsIG5leHRDb250ZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFuZGxlIHJlYWQtb25seSBjaGFuZ2VzIGluLXBsYWNlXG4gICAgICAgIGlmIChuZXh0UHJvcHMucmVhZE9ubHkgIT09IHRoaXMucHJvcHMucmVhZE9ubHkpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RWRpdG9yUmVhZE9ubHkodGhpcy5lZGl0b3IsIG5leHRQcm9wcy5yZWFkT25seSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2xlYW4gYW5kIERpcnR5IHByb3BzIHJlcXVpcmUgYSByZW5kZXJcbiAgICAgICAgcmV0dXJuIFsuLi50aGlzLmNsZWFuUHJvcHMsIC4uLnRoaXMuZGlydHlQcm9wc10uc29tZSgocHJvcCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuICFpc0VxdWFsKG5leHRQcm9wc1twcm9wXSwgdGhpcy5wcm9wc1twcm9wXSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzaG91bGRDb21wb25lbnRSZWdlbmVyYXRlKG5leHRQcm9wcykge1xuICAgICAgICAvLyBXaGVuZXZlciBhIGBkaXJ0eVByb3BgIGNoYW5nZXMsIHRoZSBlZGl0b3IgbmVlZHMgcmVpbnN0YW50aWF0aW9uLlxuICAgICAgICByZXR1cm4gdGhpcy5kaXJ0eVByb3BzLnNvbWUoKHByb3ApID0+IHtcbiAgICAgICAgICAgIHJldHVybiAhaXNFcXVhbChuZXh0UHJvcHNbcHJvcF0sIHRoaXMucHJvcHNbcHJvcF0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHRoaXMuaW5zdGFudGlhdGVFZGl0b3IoKTtcbiAgICAgICAgdGhpcy5zZXRFZGl0b3JDb250ZW50cyh0aGlzLmVkaXRvciwgdGhpcy5nZXRFZGl0b3JDb250ZW50cygpKTtcbiAgICB9XG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveUVkaXRvcigpO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzLCBwcmV2U3RhdGUpIHtcbiAgICAgICAgLy8gSWYgd2UncmUgY2hhbmdpbmcgb25lIG9mIHRoZSBgZGlydHlQcm9wc2AsIHRoZSBlbnRpcmUgUXVpbGwgRWRpdG9yIG5lZWRzXG4gICAgICAgIC8vIHRvIGJlIHJlLWluc3RhbnRpYXRlZC4gUmVnZW5lcmF0aW5nIHRoZSBlZGl0b3Igd2lsbCBjYXVzZSB0aGUgd2hvbGUgdHJlZSxcbiAgICAgICAgLy8gaW5jbHVkaW5nIHRoZSBjb250YWluZXIsIHRvIGJlIGNsZWFuZWQgdXAgYW5kIHJlLXJlbmRlcmVkIGZyb20gc2NyYXRjaC5cbiAgICAgICAgLy8gU3RvcmUgdGhlIGNvbnRlbnRzIHNvIHRoZXkgY2FuIGJlIHJlc3RvcmVkIGxhdGVyLlxuICAgICAgICBpZiAodGhpcy5lZGl0b3IgJiYgdGhpcy5zaG91bGRDb21wb25lbnRSZWdlbmVyYXRlKHByZXZQcm9wcykpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhID0gdGhpcy5lZGl0b3IuZ2V0Q29udGVudHMoKTtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IHRoaXMuZWRpdG9yLmdldFNlbGVjdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5yZWdlbmVyYXRpb25TbmFwc2hvdCA9IHsgZGVsdGEsIHNlbGVjdGlvbiB9O1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IGdlbmVyYXRpb246IHRoaXMuc3RhdGUuZ2VuZXJhdGlvbiArIDEgfSk7XG4gICAgICAgICAgICB0aGlzLmRlc3Ryb3lFZGl0b3IoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgY29tcG9uZW50IGhhcyBiZWVuIHJlZ2VuZXJhdGVkLCBzbyBpdCBtdXN0IGJlIHJlLWluc3RhbnRpYXRlZCwgYW5kXG4gICAgICAgIC8vIGl0cyBjb250ZW50IG11c3QgYmUgcmVzdG9yZWQgdG8gdGhlIHByZXZpb3VzIHZhbHVlcyBmcm9tIHRoZSBzbmFwc2hvdC5cbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuZ2VuZXJhdGlvbiAhPT0gcHJldlN0YXRlLmdlbmVyYXRpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZGVsdGEsIHNlbGVjdGlvbiB9ID0gdGhpcy5yZWdlbmVyYXRpb25TbmFwc2hvdDtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnJlZ2VuZXJhdGlvblNuYXBzaG90O1xuICAgICAgICAgICAgdGhpcy5pbnN0YW50aWF0ZUVkaXRvcigpO1xuICAgICAgICAgICAgY29uc3QgZWRpdG9yID0gdGhpcy5lZGl0b3I7XG4gICAgICAgICAgICBlZGl0b3Iuc2V0Q29udGVudHMoZGVsdGEpO1xuICAgICAgICAgICAgcG9zdHBvbmUoKCkgPT4gdGhpcy5zZXRFZGl0b3JTZWxlY3Rpb24oZWRpdG9yLCBzZWxlY3Rpb24pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpbnN0YW50aWF0ZUVkaXRvcigpIHtcbiAgICAgICAgaWYgKHRoaXMuZWRpdG9yKSB7XG4gICAgICAgICAgICB0aGlzLmhvb2tFZGl0b3IodGhpcy5lZGl0b3IpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5lZGl0b3IgPSB0aGlzLmNyZWF0ZUVkaXRvcih0aGlzLmdldEVkaXRpbmdBcmVhKCksIHRoaXMuZ2V0RWRpdG9yQ29uZmlnKCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlc3Ryb3lFZGl0b3IoKSB7XG4gICAgICAgIGlmICghdGhpcy5lZGl0b3IpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMudW5ob29rRWRpdG9yKHRoaXMuZWRpdG9yKTtcbiAgICB9XG4gICAgLypcbiAgICBXZSBjb25zaWRlciB0aGUgY29tcG9uZW50IHRvIGJlIGNvbnRyb2xsZWQgaWYgYHZhbHVlYCBpcyBiZWluZyBzZW50IGluIHByb3BzLlxuICAgICovXG4gICAgaXNDb250cm9sbGVkKCkge1xuICAgICAgICByZXR1cm4gJ3ZhbHVlJyBpbiB0aGlzLnByb3BzO1xuICAgIH1cbiAgICBnZXRFZGl0b3JDb25maWcoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBib3VuZHM6IHRoaXMucHJvcHMuYm91bmRzLFxuICAgICAgICAgICAgZm9ybWF0czogdGhpcy5wcm9wcy5mb3JtYXRzLFxuICAgICAgICAgICAgbW9kdWxlczogdGhpcy5wcm9wcy5tb2R1bGVzLFxuICAgICAgICAgICAgcGxhY2Vob2xkZXI6IHRoaXMucHJvcHMucGxhY2Vob2xkZXIsXG4gICAgICAgICAgICByZWFkT25seTogdGhpcy5wcm9wcy5yZWFkT25seSxcbiAgICAgICAgICAgIHRhYkluZGV4OiB0aGlzLnByb3BzLnRhYkluZGV4LFxuICAgICAgICAgICAgdGhlbWU6IHRoaXMucHJvcHMudGhlbWUsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldEVkaXRvcigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVkaXRvcilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQWNjZXNzaW5nIG5vbi1pbnN0YW50aWF0ZWQgZWRpdG9yJyk7XG4gICAgICAgIHJldHVybiB0aGlzLmVkaXRvcjtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlcyBhbiBlZGl0b3Igb24gdGhlIGdpdmVuIGVsZW1lbnQuIFRoZSBlZGl0b3Igd2lsbCBiZSBwYXNzZWQgdGhlXG4gICAgY29uZmlndXJhdGlvbiwgaGF2ZSBpdHMgZXZlbnRzIGJvdW5kLFxuICAgICovXG4gICAgY3JlYXRlRWRpdG9yKGVsZW1lbnQsIGNvbmZpZykge1xuICAgICAgICBjb25zdCBlZGl0b3IgPSBuZXcgUXVpbGwoZWxlbWVudCwgY29uZmlnKTtcbiAgICAgICAgaWYgKGNvbmZpZy50YWJJbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnNldEVkaXRvclRhYkluZGV4KGVkaXRvciwgY29uZmlnLnRhYkluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhvb2tFZGl0b3IoZWRpdG9yKTtcbiAgICAgICAgcmV0dXJuIGVkaXRvcjtcbiAgICB9XG4gICAgaG9va0VkaXRvcihlZGl0b3IpIHtcbiAgICAgICAgLy8gRXhwb3NlIHRoZSBlZGl0b3Igb24gY2hhbmdlIGV2ZW50cyB2aWEgYSB3ZWFrZXIsIHVucHJpdmlsZWdlZCBwcm94eVxuICAgICAgICAvLyBvYmplY3QgdGhhdCBkb2VzIG5vdCBhbGxvdyBhY2NpZGVudGFsbHkgbW9kaWZ5aW5nIGVkaXRvciBzdGF0ZS5cbiAgICAgICAgdGhpcy51bnByaXZpbGVnZWRFZGl0b3IgPSB0aGlzLm1ha2VVbnByaXZpbGVnZWRFZGl0b3IoZWRpdG9yKTtcbiAgICAgICAgLy8gVXNpbmcgYGVkaXRvci1jaGFuZ2VgIGFsbG93cyBwaWNraW5nIHVwIHNpbGVudCB1cGRhdGVzLCBsaWtlIHNlbGVjdGlvblxuICAgICAgICAvLyBjaGFuZ2VzIG9uIHR5cGluZy5cbiAgICAgICAgZWRpdG9yLm9uKCdlZGl0b3ItY2hhbmdlJywgdGhpcy5vbkVkaXRvckNoYW5nZSk7XG4gICAgfVxuICAgIHVuaG9va0VkaXRvcihlZGl0b3IpIHtcbiAgICAgICAgZWRpdG9yLm9mZignZWRpdG9yLWNoYW5nZScsIHRoaXMub25FZGl0b3JDaGFuZ2UpO1xuICAgIH1cbiAgICBnZXRFZGl0b3JDb250ZW50cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfVxuICAgIGdldEVkaXRvclNlbGVjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uO1xuICAgIH1cbiAgICAvKlxuICAgIFRydWUgaWYgdGhlIHZhbHVlIGlzIGEgRGVsdGEgaW5zdGFuY2Ugb3IgYSBEZWx0YSBsb29rLWFsaWtlLlxuICAgICovXG4gICAgaXNEZWx0YSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgJiYgdmFsdWUub3BzO1xuICAgIH1cbiAgICAvKlxuICAgIFNwZWNpYWwgY29tcGFyaXNvbiBmdW5jdGlvbiB0aGF0IGtub3dzIGhvdyB0byBjb21wYXJlIERlbHRhcy5cbiAgICAqL1xuICAgIGlzRXF1YWxWYWx1ZSh2YWx1ZSwgbmV4dFZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRGVsdGEodmFsdWUpICYmIHRoaXMuaXNEZWx0YShuZXh0VmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNFcXVhbCh2YWx1ZS5vcHMsIG5leHRWYWx1ZS5vcHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGlzRXF1YWwodmFsdWUsIG5leHRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLypcbiAgICBSZXBsYWNlIHRoZSBjb250ZW50cyBvZiB0aGUgZWRpdG9yLCBidXQga2VlcCB0aGUgcHJldmlvdXMgc2VsZWN0aW9uIGhhbmdpbmdcbiAgICBhcm91bmQgc28gdGhhdCB0aGUgY3Vyc29yIHdvbid0IG1vdmUuXG4gICAgKi9cbiAgICBzZXRFZGl0b3JDb250ZW50cyhlZGl0b3IsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgY29uc3Qgc2VsID0gdGhpcy5nZXRFZGl0b3JTZWxlY3Rpb24oKTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGVkaXRvci5zZXRDb250ZW50cyhlZGl0b3IuY2xpcGJvYXJkLmNvbnZlcnQoeyBodG1sOiB2YWx1ZSB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlZGl0b3Iuc2V0Q29udGVudHModmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHBvc3Rwb25lKCgpID0+IHRoaXMuc2V0RWRpdG9yU2VsZWN0aW9uKGVkaXRvciwgc2VsKSk7XG4gICAgfVxuICAgIHNldEVkaXRvclNlbGVjdGlvbihlZGl0b3IsIHJhbmdlKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uID0gcmFuZ2U7XG4gICAgICAgIGlmIChyYW5nZSkge1xuICAgICAgICAgICAgLy8gVmFsaWRhdGUgYm91bmRzIGJlZm9yZSBhcHBseWluZy5cbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IGVkaXRvci5nZXRMZW5ndGgoKTtcbiAgICAgICAgICAgIHJhbmdlLmluZGV4ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4ocmFuZ2UuaW5kZXgsIGxlbmd0aCAtIDEpKTtcbiAgICAgICAgICAgIHJhbmdlLmxlbmd0aCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHJhbmdlLmxlbmd0aCwgKGxlbmd0aCAtIDEpIC0gcmFuZ2UuaW5kZXgpKTtcbiAgICAgICAgICAgIGVkaXRvci5zZXRTZWxlY3Rpb24ocmFuZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldEVkaXRvclRhYkluZGV4KGVkaXRvciwgdGFiSW5kZXgpIHtcbiAgICAgICAgaWYgKGVkaXRvcj8uc2Nyb2xsPy5kb21Ob2RlKSB7XG4gICAgICAgICAgICBlZGl0b3Iuc2Nyb2xsLmRvbU5vZGUudGFiSW5kZXggPSB0YWJJbmRleDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRFZGl0b3JSZWFkT25seShlZGl0b3IsIHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgZWRpdG9yLmRpc2FibGUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVkaXRvci5lbmFibGUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKlxuICAgIFJldHVybnMgYSB3ZWFrZXIsIHVucHJpdmlsZWdlZCBwcm94eSBvYmplY3QgdGhhdCBvbmx5IGV4cG9zZXMgcmVhZC1vbmx5XG4gICAgYWNjZXNzb3JzIGZvdW5kIG9uIHRoZSBlZGl0b3IgaW5zdGFuY2UsIHdpdGhvdXQgYW55IHN0YXRlLW1vZGlmeWluZyBtZXRob2RzLlxuICAgICovXG4gICAgbWFrZVVucHJpdmlsZWdlZEVkaXRvcihlZGl0b3IpIHtcbiAgICAgICAgY29uc3QgZSA9IGVkaXRvcjtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGdldEhUTUw6ICgpID0+IGUucm9vdC5pbm5lckhUTUwsXG4gICAgICAgICAgICBnZXRTZW1hbnRpY0hUTUw6IGUuZ2V0U2VtYW50aWNIVE1MLmJpbmQoZSksXG4gICAgICAgICAgICBnZXRMZW5ndGg6IGUuZ2V0TGVuZ3RoLmJpbmQoZSksXG4gICAgICAgICAgICBnZXRUZXh0OiBlLmdldFRleHQuYmluZChlKSxcbiAgICAgICAgICAgIGdldENvbnRlbnRzOiBlLmdldENvbnRlbnRzLmJpbmQoZSksXG4gICAgICAgICAgICBnZXRTZWxlY3Rpb246IGUuZ2V0U2VsZWN0aW9uLmJpbmQoZSksXG4gICAgICAgICAgICBnZXRCb3VuZHM6IGUuZ2V0Qm91bmRzLmJpbmQoZSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldEVkaXRpbmdBcmVhKCkge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5lZGl0aW5nQXJlYVJlZi5jdXJyZW50O1xuICAgICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgZWxlbWVudCBmb3IgZWRpdGluZyBhcmVhJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsZW1lbnQubm9kZVR5cGUgPT09IDMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRWRpdGluZyBhcmVhIGNhbm5vdCBiZSBhIHRleHQgbm9kZScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cbiAgICAvKlxuICAgIFJlbmRlcnMgYW4gZWRpdG9yIGFyZWEsIHVubGVzcyBpdCBoYXMgYmVlbiBwcm92aWRlZCBvbmUgdG8gY2xvbmUuXG4gICAgKi9cbiAgICByZW5kZXJFZGl0aW5nQXJlYSgpIHtcbiAgICAgICAgY29uc3QgeyBjaGlsZHJlbiwgcHJlc2VydmVXaGl0ZXNwYWNlIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCB7IGdlbmVyYXRpb24gfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7XG4gICAgICAgICAgICBrZXk6IGdlbmVyYXRpb24sXG4gICAgICAgICAgICByZWY6IHRoaXMuZWRpdGluZ0FyZWFSZWYsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChSZWFjdC5DaGlsZHJlbi5jb3VudChjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIHJldHVybiBSZWFjdC5jbG9uZUVsZW1lbnQoUmVhY3QuQ2hpbGRyZW4ub25seShjaGlsZHJlbiksIHByb3BlcnRpZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcmVzZXJ2ZVdoaXRlc3BhY2UgP1xuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInByZVwiLCB7IC4uLnByb3BlcnRpZXMgfSkgOlxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IC4uLnByb3BlcnRpZXMgfSk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgaWQ6IHRoaXMucHJvcHMuaWQsIHN0eWxlOiB0aGlzLnByb3BzLnN0eWxlLCBrZXk6IHRoaXMuc3RhdGUuZ2VuZXJhdGlvbiwgY2xhc3NOYW1lOiBgcXVpbGwgJHt0aGlzLnByb3BzLmNsYXNzTmFtZSA/PyAnJ31gLCBvbktleVByZXNzOiB0aGlzLnByb3BzLm9uS2V5UHJlc3MsIG9uS2V5RG93bjogdGhpcy5wcm9wcy5vbktleURvd24sIG9uS2V5VXA6IHRoaXMucHJvcHMub25LZXlVcCB9LCB0aGlzLnJlbmRlckVkaXRpbmdBcmVhKCkpKTtcbiAgICB9XG4gICAgb25FZGl0b3JDaGFuZ2VUZXh0KHZhbHVlLCBkZWx0YSwgc291cmNlLCBlZGl0b3IpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVkaXRvcilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLy8gV2Uga2VlcCBzdG9yaW5nIHRoZSBzYW1lIHR5cGUgb2YgdmFsdWUgYXMgd2hhdCB0aGUgdXNlciBnaXZlcyB1cyxcbiAgICAgICAgLy8gc28gdGhhdCB2YWx1ZSBjb21wYXJpc29ucyB3aWxsIGJlIG1vcmUgc3RhYmxlIGFuZCBwcmVkaWN0YWJsZS5cbiAgICAgICAgY29uc3QgbmV4dENvbnRlbnRzID0gdGhpcy5pc0RlbHRhKHRoaXMudmFsdWUpXG4gICAgICAgICAgICA/IGVkaXRvci5nZXRDb250ZW50cygpXG4gICAgICAgICAgICA6IGVkaXRvci5nZXRIVE1MKCk7XG4gICAgICAgIGlmIChuZXh0Q29udGVudHMgIT09IHRoaXMuZ2V0RWRpdG9yQ29udGVudHMoKSkge1xuICAgICAgICAgICAgLy8gVGFpbnQgdGhpcyBgZGVsdGFgIG9iamVjdCwgc28gd2UgY2FuIHJlY29nbml6ZSB3aGV0aGVyIHRoZSB1c2VyXG4gICAgICAgICAgICAvLyBpcyB0cnlpbmcgdG8gc2VuZCBpdCBiYWNrIGFzIGB2YWx1ZWAsIHByZXZlbnRpbmcgYSBsaWtlbHkgbG9vcC5cbiAgICAgICAgICAgIHRoaXMubGFzdERlbHRhQ2hhbmdlU2V0ID0gZGVsdGE7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gbmV4dENvbnRlbnRzO1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZT8uKHZhbHVlLCBkZWx0YSwgc291cmNlLCBlZGl0b3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9uRWRpdG9yQ2hhbmdlU2VsZWN0aW9uKG5leHRTZWxlY3Rpb24sIHNvdXJjZSwgZWRpdG9yKSB7XG4gICAgICAgIGlmICghdGhpcy5lZGl0b3IpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGN1cnJlbnRTZWxlY3Rpb24gPSB0aGlzLmdldEVkaXRvclNlbGVjdGlvbigpO1xuICAgICAgICBjb25zdCBoYXNHYWluZWRGb2N1cyA9ICFjdXJyZW50U2VsZWN0aW9uICYmIG5leHRTZWxlY3Rpb247XG4gICAgICAgIGNvbnN0IGhhc0xvc3RGb2N1cyA9IGN1cnJlbnRTZWxlY3Rpb24gJiYgIW5leHRTZWxlY3Rpb247XG4gICAgICAgIGlmIChpc0VxdWFsKG5leHRTZWxlY3Rpb24sIGN1cnJlbnRTZWxlY3Rpb24pKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IG5leHRTZWxlY3Rpb247XG4gICAgICAgIHRoaXMucHJvcHMub25DaGFuZ2VTZWxlY3Rpb24/LihuZXh0U2VsZWN0aW9uLCBzb3VyY2UsIGVkaXRvcik7XG4gICAgICAgIGlmIChoYXNHYWluZWRGb2N1cykge1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkZvY3VzPy4obmV4dFNlbGVjdGlvbiwgc291cmNlLCBlZGl0b3IpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGhhc0xvc3RGb2N1cykge1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkJsdXI/LihjdXJyZW50U2VsZWN0aW9uLCBzb3VyY2UsIGVkaXRvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9jdXMoKSB7XG4gICAgICAgIGlmICghdGhpcy5lZGl0b3IpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuZWRpdG9yLmZvY3VzKCk7XG4gICAgfVxuICAgIGJsdXIoKSB7XG4gICAgICAgIGlmICghdGhpcy5lZGl0b3IpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5lZGl0b3IuYmx1cigpO1xuICAgIH1cbn1cblJlYWN0UXVpbGwuZGlzcGxheU5hbWUgPSAnUmVhY3QgUXVpbGwnO1xuLypcbkV4cG9ydCBRdWlsbCB0byBiZSBhYmxlIHRvIGNhbGwgYHJlZ2lzdGVyYFxuKi9cblJlYWN0UXVpbGwuUXVpbGwgPSBRdWlsbDtcblJlYWN0UXVpbGwuZGVmYXVsdFByb3BzID0ge1xuICAgIHRoZW1lOiAnc25vdycsXG4gICAgbW9kdWxlczoge30sXG4gICAgcmVhZE9ubHk6IGZhbHNlLFxufTtcbi8qXG5TbWFsbCBoZWxwZXIgdG8gZXhlY3V0ZSBhIGZ1bmN0aW9uIGluIHRoZSBuZXh0IG1pY3JvLXRpY2suXG4qL1xuZnVuY3Rpb24gcG9zdHBvbmUoZm4pIHtcbiAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZuKTtcbn1cbmV4cG9ydCBkZWZhdWx0IFJlYWN0UXVpbGw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-quill-new/lib/index.js\n");

/***/ })

};
;
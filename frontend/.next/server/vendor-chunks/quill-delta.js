"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/quill-delta";
exports.ids = ["vendor-chunks/quill-delta"];
exports.modules = {

/***/ "(ssr)/./node_modules/quill-delta/dist/AttributeMap.js":
/*!*******************************************************!*\
  !*** ./node_modules/quill-delta/dist/AttributeMap.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst cloneDeep = __webpack_require__(/*! lodash.clonedeep */ \"(ssr)/./node_modules/lodash.clonedeep/index.js\");\nconst isEqual = __webpack_require__(/*! lodash.isequal */ \"(ssr)/./node_modules/lodash.isequal/index.js\");\nvar AttributeMap;\n(function (AttributeMap) {\n    function compose(a = {}, b = {}, keepNull = false) {\n        if (typeof a !== 'object') {\n            a = {};\n        }\n        if (typeof b !== 'object') {\n            b = {};\n        }\n        let attributes = cloneDeep(b);\n        if (!keepNull) {\n            attributes = Object.keys(attributes).reduce((copy, key) => {\n                if (attributes[key] != null) {\n                    copy[key] = attributes[key];\n                }\n                return copy;\n            }, {});\n        }\n        for (const key in a) {\n            if (a[key] !== undefined && b[key] === undefined) {\n                attributes[key] = a[key];\n            }\n        }\n        return Object.keys(attributes).length > 0 ? attributes : undefined;\n    }\n    AttributeMap.compose = compose;\n    function diff(a = {}, b = {}) {\n        if (typeof a !== 'object') {\n            a = {};\n        }\n        if (typeof b !== 'object') {\n            b = {};\n        }\n        const attributes = Object.keys(a)\n            .concat(Object.keys(b))\n            .reduce((attrs, key) => {\n            if (!isEqual(a[key], b[key])) {\n                attrs[key] = b[key] === undefined ? null : b[key];\n            }\n            return attrs;\n        }, {});\n        return Object.keys(attributes).length > 0 ? attributes : undefined;\n    }\n    AttributeMap.diff = diff;\n    function invert(attr = {}, base = {}) {\n        attr = attr || {};\n        const baseInverted = Object.keys(base).reduce((memo, key) => {\n            if (base[key] !== attr[key] && attr[key] !== undefined) {\n                memo[key] = base[key];\n            }\n            return memo;\n        }, {});\n        return Object.keys(attr).reduce((memo, key) => {\n            if (attr[key] !== base[key] && base[key] === undefined) {\n                memo[key] = null;\n            }\n            return memo;\n        }, baseInverted);\n    }\n    AttributeMap.invert = invert;\n    function transform(a, b, priority = false) {\n        if (typeof a !== 'object') {\n            return b;\n        }\n        if (typeof b !== 'object') {\n            return undefined;\n        }\n        if (!priority) {\n            return b; // b simply overwrites us without priority\n        }\n        const attributes = Object.keys(b).reduce((attrs, key) => {\n            if (a[key] === undefined) {\n                attrs[key] = b[key]; // null is a valid value\n            }\n            return attrs;\n        }, {});\n        return Object.keys(attributes).length > 0 ? attributes : undefined;\n    }\n    AttributeMap.transform = transform;\n})(AttributeMap || (AttributeMap = {}));\nexports[\"default\"] = AttributeMap;\n//# sourceMappingURL=AttributeMap.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcXVpbGwtZGVsdGEvZGlzdC9BdHRyaWJ1dGVNYXAuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCLG1CQUFPLENBQUMsd0VBQWtCO0FBQzVDLGdCQUFnQixtQkFBTyxDQUFDLG9FQUFnQjtBQUN4QztBQUNBO0FBQ0EsMkJBQTJCLFFBQVE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLElBQUk7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLElBQUk7QUFDYjtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsV0FBVztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLElBQUk7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0EsU0FBUyxJQUFJO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvQ0FBb0M7QUFDckMsa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsid2VicGFjazovL2RvY2Fzc2lzdC8uL25vZGVfbW9kdWxlcy9xdWlsbC1kZWx0YS9kaXN0L0F0dHJpYnV0ZU1hcC5qcz85OGRlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY2xvbmVEZWVwID0gcmVxdWlyZShcImxvZGFzaC5jbG9uZWRlZXBcIik7XG5jb25zdCBpc0VxdWFsID0gcmVxdWlyZShcImxvZGFzaC5pc2VxdWFsXCIpO1xudmFyIEF0dHJpYnV0ZU1hcDtcbihmdW5jdGlvbiAoQXR0cmlidXRlTWFwKSB7XG4gICAgZnVuY3Rpb24gY29tcG9zZShhID0ge30sIGIgPSB7fSwga2VlcE51bGwgPSBmYWxzZSkge1xuICAgICAgICBpZiAodHlwZW9mIGEgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBhID0ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgYiA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGxldCBhdHRyaWJ1dGVzID0gY2xvbmVEZWVwKGIpO1xuICAgICAgICBpZiAoIWtlZXBOdWxsKSB7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzID0gT2JqZWN0LmtleXMoYXR0cmlidXRlcykucmVkdWNlKChjb3B5LCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoYXR0cmlidXRlc1trZXldICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29weVtrZXldID0gYXR0cmlidXRlc1trZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY29weTtcbiAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBhKSB7XG4gICAgICAgICAgICBpZiAoYVtrZXldICE9PSB1bmRlZmluZWQgJiYgYltrZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzW2tleV0gPSBhW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmxlbmd0aCA+IDAgPyBhdHRyaWJ1dGVzIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBBdHRyaWJ1dGVNYXAuY29tcG9zZSA9IGNvbXBvc2U7XG4gICAgZnVuY3Rpb24gZGlmZihhID0ge30sIGIgPSB7fSkge1xuICAgICAgICBpZiAodHlwZW9mIGEgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBhID0ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgYiA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBPYmplY3Qua2V5cyhhKVxuICAgICAgICAgICAgLmNvbmNhdChPYmplY3Qua2V5cyhiKSlcbiAgICAgICAgICAgIC5yZWR1Y2UoKGF0dHJzLCBrZXkpID0+IHtcbiAgICAgICAgICAgIGlmICghaXNFcXVhbChhW2tleV0sIGJba2V5XSkpIHtcbiAgICAgICAgICAgICAgICBhdHRyc1trZXldID0gYltrZXldID09PSB1bmRlZmluZWQgPyBudWxsIDogYltrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGF0dHJzO1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5sZW5ndGggPiAwID8gYXR0cmlidXRlcyA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgQXR0cmlidXRlTWFwLmRpZmYgPSBkaWZmO1xuICAgIGZ1bmN0aW9uIGludmVydChhdHRyID0ge30sIGJhc2UgPSB7fSkge1xuICAgICAgICBhdHRyID0gYXR0ciB8fCB7fTtcbiAgICAgICAgY29uc3QgYmFzZUludmVydGVkID0gT2JqZWN0LmtleXMoYmFzZSkucmVkdWNlKChtZW1vLCBrZXkpID0+IHtcbiAgICAgICAgICAgIGlmIChiYXNlW2tleV0gIT09IGF0dHJba2V5XSAmJiBhdHRyW2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG1lbW9ba2V5XSA9IGJhc2Vba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZW1vO1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhhdHRyKS5yZWR1Y2UoKG1lbW8sIGtleSkgPT4ge1xuICAgICAgICAgICAgaWYgKGF0dHJba2V5XSAhPT0gYmFzZVtrZXldICYmIGJhc2Vba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbWVtb1trZXldID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZW1vO1xuICAgICAgICB9LCBiYXNlSW52ZXJ0ZWQpO1xuICAgIH1cbiAgICBBdHRyaWJ1dGVNYXAuaW52ZXJ0ID0gaW52ZXJ0O1xuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybShhLCBiLCBwcmlvcml0eSA9IGZhbHNlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiBiO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwcmlvcml0eSkge1xuICAgICAgICAgICAgcmV0dXJuIGI7IC8vIGIgc2ltcGx5IG92ZXJ3cml0ZXMgdXMgd2l0aG91dCBwcmlvcml0eVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBPYmplY3Qua2V5cyhiKS5yZWR1Y2UoKGF0dHJzLCBrZXkpID0+IHtcbiAgICAgICAgICAgIGlmIChhW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGF0dHJzW2tleV0gPSBiW2tleV07IC8vIG51bGwgaXMgYSB2YWxpZCB2YWx1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGF0dHJzO1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5sZW5ndGggPiAwID8gYXR0cmlidXRlcyA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgQXR0cmlidXRlTWFwLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbn0pKEF0dHJpYnV0ZU1hcCB8fCAoQXR0cmlidXRlTWFwID0ge30pKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEF0dHJpYnV0ZU1hcDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUF0dHJpYnV0ZU1hcC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/quill-delta/dist/AttributeMap.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/quill-delta/dist/Delta.js":
/*!************************************************!*\
  !*** ./node_modules/quill-delta/dist/Delta.js ***!
  \************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AttributeMap = exports.OpIterator = exports.Op = void 0;\nconst diff = __webpack_require__(/*! fast-diff */ \"(ssr)/./node_modules/fast-diff/diff.js\");\nconst cloneDeep = __webpack_require__(/*! lodash.clonedeep */ \"(ssr)/./node_modules/lodash.clonedeep/index.js\");\nconst isEqual = __webpack_require__(/*! lodash.isequal */ \"(ssr)/./node_modules/lodash.isequal/index.js\");\nconst AttributeMap_1 = __webpack_require__(/*! ./AttributeMap */ \"(ssr)/./node_modules/quill-delta/dist/AttributeMap.js\");\nexports.AttributeMap = AttributeMap_1.default;\nconst Op_1 = __webpack_require__(/*! ./Op */ \"(ssr)/./node_modules/quill-delta/dist/Op.js\");\nexports.Op = Op_1.default;\nconst OpIterator_1 = __webpack_require__(/*! ./OpIterator */ \"(ssr)/./node_modules/quill-delta/dist/OpIterator.js\");\nexports.OpIterator = OpIterator_1.default;\nconst NULL_CHARACTER = String.fromCharCode(0); // Placeholder char for embed in diff()\nconst getEmbedTypeAndData = (a, b) => {\n    if (typeof a !== 'object' || a === null) {\n        throw new Error(`cannot retain a ${typeof a}`);\n    }\n    if (typeof b !== 'object' || b === null) {\n        throw new Error(`cannot retain a ${typeof b}`);\n    }\n    const embedType = Object.keys(a)[0];\n    if (!embedType || embedType !== Object.keys(b)[0]) {\n        throw new Error(`embed types not matched: ${embedType} != ${Object.keys(b)[0]}`);\n    }\n    return [embedType, a[embedType], b[embedType]];\n};\nclass Delta {\n    constructor(ops) {\n        // Assume we are given a well formed ops\n        if (Array.isArray(ops)) {\n            this.ops = ops;\n        }\n        else if (ops != null && Array.isArray(ops.ops)) {\n            this.ops = ops.ops;\n        }\n        else {\n            this.ops = [];\n        }\n    }\n    static registerEmbed(embedType, handler) {\n        this.handlers[embedType] = handler;\n    }\n    static unregisterEmbed(embedType) {\n        delete this.handlers[embedType];\n    }\n    static getHandler(embedType) {\n        const handler = this.handlers[embedType];\n        if (!handler) {\n            throw new Error(`no handlers for embed type \"${embedType}\"`);\n        }\n        return handler;\n    }\n    insert(arg, attributes) {\n        const newOp = {};\n        if (typeof arg === 'string' && arg.length === 0) {\n            return this;\n        }\n        newOp.insert = arg;\n        if (attributes != null &&\n            typeof attributes === 'object' &&\n            Object.keys(attributes).length > 0) {\n            newOp.attributes = attributes;\n        }\n        return this.push(newOp);\n    }\n    delete(length) {\n        if (length <= 0) {\n            return this;\n        }\n        return this.push({ delete: length });\n    }\n    retain(length, attributes) {\n        if (typeof length === 'number' && length <= 0) {\n            return this;\n        }\n        const newOp = { retain: length };\n        if (attributes != null &&\n            typeof attributes === 'object' &&\n            Object.keys(attributes).length > 0) {\n            newOp.attributes = attributes;\n        }\n        return this.push(newOp);\n    }\n    push(newOp) {\n        let index = this.ops.length;\n        let lastOp = this.ops[index - 1];\n        newOp = cloneDeep(newOp);\n        if (typeof lastOp === 'object') {\n            if (typeof newOp.delete === 'number' &&\n                typeof lastOp.delete === 'number') {\n                this.ops[index - 1] = { delete: lastOp.delete + newOp.delete };\n                return this;\n            }\n            // Since it does not matter if we insert before or after deleting at the same index,\n            // always prefer to insert first\n            if (typeof lastOp.delete === 'number' && newOp.insert != null) {\n                index -= 1;\n                lastOp = this.ops[index - 1];\n                if (typeof lastOp !== 'object') {\n                    this.ops.unshift(newOp);\n                    return this;\n                }\n            }\n            if (isEqual(newOp.attributes, lastOp.attributes)) {\n                if (typeof newOp.insert === 'string' &&\n                    typeof lastOp.insert === 'string') {\n                    this.ops[index - 1] = { insert: lastOp.insert + newOp.insert };\n                    if (typeof newOp.attributes === 'object') {\n                        this.ops[index - 1].attributes = newOp.attributes;\n                    }\n                    return this;\n                }\n                else if (typeof newOp.retain === 'number' &&\n                    typeof lastOp.retain === 'number') {\n                    this.ops[index - 1] = { retain: lastOp.retain + newOp.retain };\n                    if (typeof newOp.attributes === 'object') {\n                        this.ops[index - 1].attributes = newOp.attributes;\n                    }\n                    return this;\n                }\n            }\n        }\n        if (index === this.ops.length) {\n            this.ops.push(newOp);\n        }\n        else {\n            this.ops.splice(index, 0, newOp);\n        }\n        return this;\n    }\n    chop() {\n        const lastOp = this.ops[this.ops.length - 1];\n        if (lastOp && typeof lastOp.retain === 'number' && !lastOp.attributes) {\n            this.ops.pop();\n        }\n        return this;\n    }\n    filter(predicate) {\n        return this.ops.filter(predicate);\n    }\n    forEach(predicate) {\n        this.ops.forEach(predicate);\n    }\n    map(predicate) {\n        return this.ops.map(predicate);\n    }\n    partition(predicate) {\n        const passed = [];\n        const failed = [];\n        this.forEach((op) => {\n            const target = predicate(op) ? passed : failed;\n            target.push(op);\n        });\n        return [passed, failed];\n    }\n    reduce(predicate, initialValue) {\n        return this.ops.reduce(predicate, initialValue);\n    }\n    changeLength() {\n        return this.reduce((length, elem) => {\n            if (elem.insert) {\n                return length + Op_1.default.length(elem);\n            }\n            else if (elem.delete) {\n                return length - elem.delete;\n            }\n            return length;\n        }, 0);\n    }\n    length() {\n        return this.reduce((length, elem) => {\n            return length + Op_1.default.length(elem);\n        }, 0);\n    }\n    slice(start = 0, end = Infinity) {\n        const ops = [];\n        const iter = new OpIterator_1.default(this.ops);\n        let index = 0;\n        while (index < end && iter.hasNext()) {\n            let nextOp;\n            if (index < start) {\n                nextOp = iter.next(start - index);\n            }\n            else {\n                nextOp = iter.next(end - index);\n                ops.push(nextOp);\n            }\n            index += Op_1.default.length(nextOp);\n        }\n        return new Delta(ops);\n    }\n    compose(other) {\n        const thisIter = new OpIterator_1.default(this.ops);\n        const otherIter = new OpIterator_1.default(other.ops);\n        const ops = [];\n        const firstOther = otherIter.peek();\n        if (firstOther != null &&\n            typeof firstOther.retain === 'number' &&\n            firstOther.attributes == null) {\n            let firstLeft = firstOther.retain;\n            while (thisIter.peekType() === 'insert' &&\n                thisIter.peekLength() <= firstLeft) {\n                firstLeft -= thisIter.peekLength();\n                ops.push(thisIter.next());\n            }\n            if (firstOther.retain - firstLeft > 0) {\n                otherIter.next(firstOther.retain - firstLeft);\n            }\n        }\n        const delta = new Delta(ops);\n        while (thisIter.hasNext() || otherIter.hasNext()) {\n            if (otherIter.peekType() === 'insert') {\n                delta.push(otherIter.next());\n            }\n            else if (thisIter.peekType() === 'delete') {\n                delta.push(thisIter.next());\n            }\n            else {\n                const length = Math.min(thisIter.peekLength(), otherIter.peekLength());\n                const thisOp = thisIter.next(length);\n                const otherOp = otherIter.next(length);\n                if (otherOp.retain) {\n                    const newOp = {};\n                    if (typeof thisOp.retain === 'number') {\n                        newOp.retain =\n                            typeof otherOp.retain === 'number' ? length : otherOp.retain;\n                    }\n                    else {\n                        if (typeof otherOp.retain === 'number') {\n                            if (thisOp.retain == null) {\n                                newOp.insert = thisOp.insert;\n                            }\n                            else {\n                                newOp.retain = thisOp.retain;\n                            }\n                        }\n                        else {\n                            const action = thisOp.retain == null ? 'insert' : 'retain';\n                            const [embedType, thisData, otherData] = getEmbedTypeAndData(thisOp[action], otherOp.retain);\n                            const handler = Delta.getHandler(embedType);\n                            newOp[action] = {\n                                [embedType]: handler.compose(thisData, otherData, action === 'retain'),\n                            };\n                        }\n                    }\n                    // Preserve null when composing with a retain, otherwise remove it for inserts\n                    const attributes = AttributeMap_1.default.compose(thisOp.attributes, otherOp.attributes, typeof thisOp.retain === 'number');\n                    if (attributes) {\n                        newOp.attributes = attributes;\n                    }\n                    delta.push(newOp);\n                    // Optimization if rest of other is just retain\n                    if (!otherIter.hasNext() &&\n                        isEqual(delta.ops[delta.ops.length - 1], newOp)) {\n                        const rest = new Delta(thisIter.rest());\n                        return delta.concat(rest).chop();\n                    }\n                    // Other op should be delete, we could be an insert or retain\n                    // Insert + delete cancels out\n                }\n                else if (typeof otherOp.delete === 'number' &&\n                    (typeof thisOp.retain === 'number' ||\n                        (typeof thisOp.retain === 'object' && thisOp.retain !== null))) {\n                    delta.push(otherOp);\n                }\n            }\n        }\n        return delta.chop();\n    }\n    concat(other) {\n        const delta = new Delta(this.ops.slice());\n        if (other.ops.length > 0) {\n            delta.push(other.ops[0]);\n            delta.ops = delta.ops.concat(other.ops.slice(1));\n        }\n        return delta;\n    }\n    diff(other, cursor) {\n        if (this.ops === other.ops) {\n            return new Delta();\n        }\n        const strings = [this, other].map((delta) => {\n            return delta\n                .map((op) => {\n                if (op.insert != null) {\n                    return typeof op.insert === 'string' ? op.insert : NULL_CHARACTER;\n                }\n                const prep = delta === other ? 'on' : 'with';\n                throw new Error('diff() called ' + prep + ' non-document');\n            })\n                .join('');\n        });\n        const retDelta = new Delta();\n        const diffResult = diff(strings[0], strings[1], cursor, true);\n        const thisIter = new OpIterator_1.default(this.ops);\n        const otherIter = new OpIterator_1.default(other.ops);\n        diffResult.forEach((component) => {\n            let length = component[1].length;\n            while (length > 0) {\n                let opLength = 0;\n                switch (component[0]) {\n                    case diff.INSERT:\n                        opLength = Math.min(otherIter.peekLength(), length);\n                        retDelta.push(otherIter.next(opLength));\n                        break;\n                    case diff.DELETE:\n                        opLength = Math.min(length, thisIter.peekLength());\n                        thisIter.next(opLength);\n                        retDelta.delete(opLength);\n                        break;\n                    case diff.EQUAL:\n                        opLength = Math.min(thisIter.peekLength(), otherIter.peekLength(), length);\n                        const thisOp = thisIter.next(opLength);\n                        const otherOp = otherIter.next(opLength);\n                        if (isEqual(thisOp.insert, otherOp.insert)) {\n                            retDelta.retain(opLength, AttributeMap_1.default.diff(thisOp.attributes, otherOp.attributes));\n                        }\n                        else {\n                            retDelta.push(otherOp).delete(opLength);\n                        }\n                        break;\n                }\n                length -= opLength;\n            }\n        });\n        return retDelta.chop();\n    }\n    eachLine(predicate, newline = '\\n') {\n        const iter = new OpIterator_1.default(this.ops);\n        let line = new Delta();\n        let i = 0;\n        while (iter.hasNext()) {\n            if (iter.peekType() !== 'insert') {\n                return;\n            }\n            const thisOp = iter.peek();\n            const start = Op_1.default.length(thisOp) - iter.peekLength();\n            const index = typeof thisOp.insert === 'string'\n                ? thisOp.insert.indexOf(newline, start) - start\n                : -1;\n            if (index < 0) {\n                line.push(iter.next());\n            }\n            else if (index > 0) {\n                line.push(iter.next(index));\n            }\n            else {\n                if (predicate(line, iter.next(1).attributes || {}, i) === false) {\n                    return;\n                }\n                i += 1;\n                line = new Delta();\n            }\n        }\n        if (line.length() > 0) {\n            predicate(line, {}, i);\n        }\n    }\n    invert(base) {\n        const inverted = new Delta();\n        this.reduce((baseIndex, op) => {\n            if (op.insert) {\n                inverted.delete(Op_1.default.length(op));\n            }\n            else if (typeof op.retain === 'number' && op.attributes == null) {\n                inverted.retain(op.retain);\n                return baseIndex + op.retain;\n            }\n            else if (op.delete || typeof op.retain === 'number') {\n                const length = (op.delete || op.retain);\n                const slice = base.slice(baseIndex, baseIndex + length);\n                slice.forEach((baseOp) => {\n                    if (op.delete) {\n                        inverted.push(baseOp);\n                    }\n                    else if (op.retain && op.attributes) {\n                        inverted.retain(Op_1.default.length(baseOp), AttributeMap_1.default.invert(op.attributes, baseOp.attributes));\n                    }\n                });\n                return baseIndex + length;\n            }\n            else if (typeof op.retain === 'object' && op.retain !== null) {\n                const slice = base.slice(baseIndex, baseIndex + 1);\n                const baseOp = new OpIterator_1.default(slice.ops).next();\n                const [embedType, opData, baseOpData] = getEmbedTypeAndData(op.retain, baseOp.insert);\n                const handler = Delta.getHandler(embedType);\n                inverted.retain({ [embedType]: handler.invert(opData, baseOpData) }, AttributeMap_1.default.invert(op.attributes, baseOp.attributes));\n                return baseIndex + 1;\n            }\n            return baseIndex;\n        }, 0);\n        return inverted.chop();\n    }\n    transform(arg, priority = false) {\n        priority = !!priority;\n        if (typeof arg === 'number') {\n            return this.transformPosition(arg, priority);\n        }\n        const other = arg;\n        const thisIter = new OpIterator_1.default(this.ops);\n        const otherIter = new OpIterator_1.default(other.ops);\n        const delta = new Delta();\n        while (thisIter.hasNext() || otherIter.hasNext()) {\n            if (thisIter.peekType() === 'insert' &&\n                (priority || otherIter.peekType() !== 'insert')) {\n                delta.retain(Op_1.default.length(thisIter.next()));\n            }\n            else if (otherIter.peekType() === 'insert') {\n                delta.push(otherIter.next());\n            }\n            else {\n                const length = Math.min(thisIter.peekLength(), otherIter.peekLength());\n                const thisOp = thisIter.next(length);\n                const otherOp = otherIter.next(length);\n                if (thisOp.delete) {\n                    // Our delete either makes their delete redundant or removes their retain\n                    continue;\n                }\n                else if (otherOp.delete) {\n                    delta.push(otherOp);\n                }\n                else {\n                    const thisData = thisOp.retain;\n                    const otherData = otherOp.retain;\n                    let transformedData = typeof otherData === 'object' && otherData !== null\n                        ? otherData\n                        : length;\n                    if (typeof thisData === 'object' &&\n                        thisData !== null &&\n                        typeof otherData === 'object' &&\n                        otherData !== null) {\n                        const embedType = Object.keys(thisData)[0];\n                        if (embedType === Object.keys(otherData)[0]) {\n                            const handler = Delta.getHandler(embedType);\n                            if (handler) {\n                                transformedData = {\n                                    [embedType]: handler.transform(thisData[embedType], otherData[embedType], priority),\n                                };\n                            }\n                        }\n                    }\n                    // We retain either their retain or insert\n                    delta.retain(transformedData, AttributeMap_1.default.transform(thisOp.attributes, otherOp.attributes, priority));\n                }\n            }\n        }\n        return delta.chop();\n    }\n    transformPosition(index, priority = false) {\n        priority = !!priority;\n        const thisIter = new OpIterator_1.default(this.ops);\n        let offset = 0;\n        while (thisIter.hasNext() && offset <= index) {\n            const length = thisIter.peekLength();\n            const nextType = thisIter.peekType();\n            thisIter.next();\n            if (nextType === 'delete') {\n                index -= Math.min(length, index - offset);\n                continue;\n            }\n            else if (nextType === 'insert' && (offset < index || !priority)) {\n                index += length;\n            }\n            offset += length;\n        }\n        return index;\n    }\n}\nDelta.Op = Op_1.default;\nDelta.OpIterator = OpIterator_1.default;\nDelta.AttributeMap = AttributeMap_1.default;\nDelta.handlers = {};\nexports[\"default\"] = Delta;\nif (true) {\n    module.exports = Delta;\n    module.exports[\"default\"] = Delta;\n}\n//# sourceMappingURL=Delta.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcXVpbGwtZGVsdGEvZGlzdC9EZWx0YS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0IsR0FBRyxrQkFBa0IsR0FBRyxVQUFVO0FBQ3RELGFBQWEsbUJBQU8sQ0FBQyx5REFBVztBQUNoQyxrQkFBa0IsbUJBQU8sQ0FBQyx3RUFBa0I7QUFDNUMsZ0JBQWdCLG1CQUFPLENBQUMsb0VBQWdCO0FBQ3hDLHVCQUF1QixtQkFBTyxDQUFDLDZFQUFnQjtBQUMvQyxvQkFBb0I7QUFDcEIsYUFBYSxtQkFBTyxDQUFDLHlEQUFNO0FBQzNCLFVBQVU7QUFDVixxQkFBcUIsbUJBQU8sQ0FBQyx5RUFBYztBQUMzQyxrQkFBa0I7QUFDbEIsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQSwyQ0FBMkMsU0FBUztBQUNwRDtBQUNBO0FBQ0EsMkNBQTJDLFNBQVM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFdBQVcsS0FBSyxrQkFBa0I7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsVUFBVTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdCQUFnQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGlEQUFpRDtBQUNuRjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWU7QUFDZixJQUFJLElBQTBCO0FBQzlCO0FBQ0EsSUFBSSx5QkFBc0I7QUFDMUI7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2RvY2Fzc2lzdC8uL25vZGVfbW9kdWxlcy9xdWlsbC1kZWx0YS9kaXN0L0RlbHRhLmpzP2Q5YzAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkF0dHJpYnV0ZU1hcCA9IGV4cG9ydHMuT3BJdGVyYXRvciA9IGV4cG9ydHMuT3AgPSB2b2lkIDA7XG5jb25zdCBkaWZmID0gcmVxdWlyZShcImZhc3QtZGlmZlwiKTtcbmNvbnN0IGNsb25lRGVlcCA9IHJlcXVpcmUoXCJsb2Rhc2guY2xvbmVkZWVwXCIpO1xuY29uc3QgaXNFcXVhbCA9IHJlcXVpcmUoXCJsb2Rhc2guaXNlcXVhbFwiKTtcbmNvbnN0IEF0dHJpYnV0ZU1hcF8xID0gcmVxdWlyZShcIi4vQXR0cmlidXRlTWFwXCIpO1xuZXhwb3J0cy5BdHRyaWJ1dGVNYXAgPSBBdHRyaWJ1dGVNYXBfMS5kZWZhdWx0O1xuY29uc3QgT3BfMSA9IHJlcXVpcmUoXCIuL09wXCIpO1xuZXhwb3J0cy5PcCA9IE9wXzEuZGVmYXVsdDtcbmNvbnN0IE9wSXRlcmF0b3JfMSA9IHJlcXVpcmUoXCIuL09wSXRlcmF0b3JcIik7XG5leHBvcnRzLk9wSXRlcmF0b3IgPSBPcEl0ZXJhdG9yXzEuZGVmYXVsdDtcbmNvbnN0IE5VTExfQ0hBUkFDVEVSID0gU3RyaW5nLmZyb21DaGFyQ29kZSgwKTsgLy8gUGxhY2Vob2xkZXIgY2hhciBmb3IgZW1iZWQgaW4gZGlmZigpXG5jb25zdCBnZXRFbWJlZFR5cGVBbmREYXRhID0gKGEsIGIpID0+IHtcbiAgICBpZiAodHlwZW9mIGEgIT09ICdvYmplY3QnIHx8IGEgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgcmV0YWluIGEgJHt0eXBlb2YgYX1gKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBiICE9PSAnb2JqZWN0JyB8fCBiID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IHJldGFpbiBhICR7dHlwZW9mIGJ9YCk7XG4gICAgfVxuICAgIGNvbnN0IGVtYmVkVHlwZSA9IE9iamVjdC5rZXlzKGEpWzBdO1xuICAgIGlmICghZW1iZWRUeXBlIHx8IGVtYmVkVHlwZSAhPT0gT2JqZWN0LmtleXMoYilbMF0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBlbWJlZCB0eXBlcyBub3QgbWF0Y2hlZDogJHtlbWJlZFR5cGV9ICE9ICR7T2JqZWN0LmtleXMoYilbMF19YCk7XG4gICAgfVxuICAgIHJldHVybiBbZW1iZWRUeXBlLCBhW2VtYmVkVHlwZV0sIGJbZW1iZWRUeXBlXV07XG59O1xuY2xhc3MgRGVsdGEge1xuICAgIGNvbnN0cnVjdG9yKG9wcykge1xuICAgICAgICAvLyBBc3N1bWUgd2UgYXJlIGdpdmVuIGEgd2VsbCBmb3JtZWQgb3BzXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9wcykpIHtcbiAgICAgICAgICAgIHRoaXMub3BzID0gb3BzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wcyAhPSBudWxsICYmIEFycmF5LmlzQXJyYXkob3BzLm9wcykpIHtcbiAgICAgICAgICAgIHRoaXMub3BzID0gb3BzLm9wcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub3BzID0gW107XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIHJlZ2lzdGVyRW1iZWQoZW1iZWRUeXBlLCBoYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlcnNbZW1iZWRUeXBlXSA9IGhhbmRsZXI7XG4gICAgfVxuICAgIHN0YXRpYyB1bnJlZ2lzdGVyRW1iZWQoZW1iZWRUeXBlKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmhhbmRsZXJzW2VtYmVkVHlwZV07XG4gICAgfVxuICAgIHN0YXRpYyBnZXRIYW5kbGVyKGVtYmVkVHlwZSkge1xuICAgICAgICBjb25zdCBoYW5kbGVyID0gdGhpcy5oYW5kbGVyc1tlbWJlZFR5cGVdO1xuICAgICAgICBpZiAoIWhhbmRsZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgbm8gaGFuZGxlcnMgZm9yIGVtYmVkIHR5cGUgXCIke2VtYmVkVHlwZX1cImApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoYW5kbGVyO1xuICAgIH1cbiAgICBpbnNlcnQoYXJnLCBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIGNvbnN0IG5ld09wID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJyAmJiBhcmcubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBuZXdPcC5pbnNlcnQgPSBhcmc7XG4gICAgICAgIGlmIChhdHRyaWJ1dGVzICE9IG51bGwgJiZcbiAgICAgICAgICAgIHR5cGVvZiBhdHRyaWJ1dGVzID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbmV3T3AuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucHVzaChuZXdPcCk7XG4gICAgfVxuICAgIGRlbGV0ZShsZW5ndGgpIHtcbiAgICAgICAgaWYgKGxlbmd0aCA8PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wdXNoKHsgZGVsZXRlOiBsZW5ndGggfSk7XG4gICAgfVxuICAgIHJldGFpbihsZW5ndGgsIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBsZW5ndGggPT09ICdudW1iZXInICYmIGxlbmd0aCA8PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdPcCA9IHsgcmV0YWluOiBsZW5ndGggfTtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZXMgIT0gbnVsbCAmJlxuICAgICAgICAgICAgdHlwZW9mIGF0dHJpYnV0ZXMgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBuZXdPcC5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wdXNoKG5ld09wKTtcbiAgICB9XG4gICAgcHVzaChuZXdPcCkge1xuICAgICAgICBsZXQgaW5kZXggPSB0aGlzLm9wcy5sZW5ndGg7XG4gICAgICAgIGxldCBsYXN0T3AgPSB0aGlzLm9wc1tpbmRleCAtIDFdO1xuICAgICAgICBuZXdPcCA9IGNsb25lRGVlcChuZXdPcCk7XG4gICAgICAgIGlmICh0eXBlb2YgbGFzdE9wID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBuZXdPcC5kZWxldGUgPT09ICdudW1iZXInICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGxhc3RPcC5kZWxldGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHNbaW5kZXggLSAxXSA9IHsgZGVsZXRlOiBsYXN0T3AuZGVsZXRlICsgbmV3T3AuZGVsZXRlIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTaW5jZSBpdCBkb2VzIG5vdCBtYXR0ZXIgaWYgd2UgaW5zZXJ0IGJlZm9yZSBvciBhZnRlciBkZWxldGluZyBhdCB0aGUgc2FtZSBpbmRleCxcbiAgICAgICAgICAgIC8vIGFsd2F5cyBwcmVmZXIgdG8gaW5zZXJ0IGZpcnN0XG4gICAgICAgICAgICBpZiAodHlwZW9mIGxhc3RPcC5kZWxldGUgPT09ICdudW1iZXInICYmIG5ld09wLmluc2VydCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggLT0gMTtcbiAgICAgICAgICAgICAgICBsYXN0T3AgPSB0aGlzLm9wc1tpbmRleCAtIDFdO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbGFzdE9wICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wcy51bnNoaWZ0KG5ld09wKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzRXF1YWwobmV3T3AuYXR0cmlidXRlcywgbGFzdE9wLmF0dHJpYnV0ZXMpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBuZXdPcC5pbnNlcnQgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBsYXN0T3AuaW5zZXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wc1tpbmRleCAtIDFdID0geyBpbnNlcnQ6IGxhc3RPcC5pbnNlcnQgKyBuZXdPcC5pbnNlcnQgfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBuZXdPcC5hdHRyaWJ1dGVzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHNbaW5kZXggLSAxXS5hdHRyaWJ1dGVzID0gbmV3T3AuYXR0cmlidXRlcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG5ld09wLnJldGFpbiA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGxhc3RPcC5yZXRhaW4gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3BzW2luZGV4IC0gMV0gPSB7IHJldGFpbjogbGFzdE9wLnJldGFpbiArIG5ld09wLnJldGFpbiB9O1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG5ld09wLmF0dHJpYnV0ZXMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9wc1tpbmRleCAtIDFdLmF0dHJpYnV0ZXMgPSBuZXdPcC5hdHRyaWJ1dGVzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5kZXggPT09IHRoaXMub3BzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5vcHMucHVzaChuZXdPcCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9wcy5zcGxpY2UoaW5kZXgsIDAsIG5ld09wKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgY2hvcCgpIHtcbiAgICAgICAgY29uc3QgbGFzdE9wID0gdGhpcy5vcHNbdGhpcy5vcHMubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChsYXN0T3AgJiYgdHlwZW9mIGxhc3RPcC5yZXRhaW4gPT09ICdudW1iZXInICYmICFsYXN0T3AuYXR0cmlidXRlcykge1xuICAgICAgICAgICAgdGhpcy5vcHMucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGZpbHRlcihwcmVkaWNhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3BzLmZpbHRlcihwcmVkaWNhdGUpO1xuICAgIH1cbiAgICBmb3JFYWNoKHByZWRpY2F0ZSkge1xuICAgICAgICB0aGlzLm9wcy5mb3JFYWNoKHByZWRpY2F0ZSk7XG4gICAgfVxuICAgIG1hcChwcmVkaWNhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3BzLm1hcChwcmVkaWNhdGUpO1xuICAgIH1cbiAgICBwYXJ0aXRpb24ocHJlZGljYXRlKSB7XG4gICAgICAgIGNvbnN0IHBhc3NlZCA9IFtdO1xuICAgICAgICBjb25zdCBmYWlsZWQgPSBbXTtcbiAgICAgICAgdGhpcy5mb3JFYWNoKChvcCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gcHJlZGljYXRlKG9wKSA/IHBhc3NlZCA6IGZhaWxlZDtcbiAgICAgICAgICAgIHRhcmdldC5wdXNoKG9wKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBbcGFzc2VkLCBmYWlsZWRdO1xuICAgIH1cbiAgICByZWR1Y2UocHJlZGljYXRlLCBpbml0aWFsVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3BzLnJlZHVjZShwcmVkaWNhdGUsIGluaXRpYWxWYWx1ZSk7XG4gICAgfVxuICAgIGNoYW5nZUxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVkdWNlKChsZW5ndGgsIGVsZW0pID0+IHtcbiAgICAgICAgICAgIGlmIChlbGVtLmluc2VydCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsZW5ndGggKyBPcF8xLmRlZmF1bHQubGVuZ3RoKGVsZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZWxlbS5kZWxldGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVuZ3RoIC0gZWxlbS5kZWxldGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbGVuZ3RoO1xuICAgICAgICB9LCAwKTtcbiAgICB9XG4gICAgbGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWR1Y2UoKGxlbmd0aCwgZWxlbSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGxlbmd0aCArIE9wXzEuZGVmYXVsdC5sZW5ndGgoZWxlbSk7XG4gICAgICAgIH0sIDApO1xuICAgIH1cbiAgICBzbGljZShzdGFydCA9IDAsIGVuZCA9IEluZmluaXR5KSB7XG4gICAgICAgIGNvbnN0IG9wcyA9IFtdO1xuICAgICAgICBjb25zdCBpdGVyID0gbmV3IE9wSXRlcmF0b3JfMS5kZWZhdWx0KHRoaXMub3BzKTtcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgd2hpbGUgKGluZGV4IDwgZW5kICYmIGl0ZXIuaGFzTmV4dCgpKSB7XG4gICAgICAgICAgICBsZXQgbmV4dE9wO1xuICAgICAgICAgICAgaWYgKGluZGV4IDwgc3RhcnQpIHtcbiAgICAgICAgICAgICAgICBuZXh0T3AgPSBpdGVyLm5leHQoc3RhcnQgLSBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXh0T3AgPSBpdGVyLm5leHQoZW5kIC0gaW5kZXgpO1xuICAgICAgICAgICAgICAgIG9wcy5wdXNoKG5leHRPcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbmRleCArPSBPcF8xLmRlZmF1bHQubGVuZ3RoKG5leHRPcCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBEZWx0YShvcHMpO1xuICAgIH1cbiAgICBjb21wb3NlKG90aGVyKSB7XG4gICAgICAgIGNvbnN0IHRoaXNJdGVyID0gbmV3IE9wSXRlcmF0b3JfMS5kZWZhdWx0KHRoaXMub3BzKTtcbiAgICAgICAgY29uc3Qgb3RoZXJJdGVyID0gbmV3IE9wSXRlcmF0b3JfMS5kZWZhdWx0KG90aGVyLm9wcyk7XG4gICAgICAgIGNvbnN0IG9wcyA9IFtdO1xuICAgICAgICBjb25zdCBmaXJzdE90aGVyID0gb3RoZXJJdGVyLnBlZWsoKTtcbiAgICAgICAgaWYgKGZpcnN0T3RoZXIgIT0gbnVsbCAmJlxuICAgICAgICAgICAgdHlwZW9mIGZpcnN0T3RoZXIucmV0YWluID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgICAgZmlyc3RPdGhlci5hdHRyaWJ1dGVzID09IG51bGwpIHtcbiAgICAgICAgICAgIGxldCBmaXJzdExlZnQgPSBmaXJzdE90aGVyLnJldGFpbjtcbiAgICAgICAgICAgIHdoaWxlICh0aGlzSXRlci5wZWVrVHlwZSgpID09PSAnaW5zZXJ0JyAmJlxuICAgICAgICAgICAgICAgIHRoaXNJdGVyLnBlZWtMZW5ndGgoKSA8PSBmaXJzdExlZnQpIHtcbiAgICAgICAgICAgICAgICBmaXJzdExlZnQgLT0gdGhpc0l0ZXIucGVla0xlbmd0aCgpO1xuICAgICAgICAgICAgICAgIG9wcy5wdXNoKHRoaXNJdGVyLm5leHQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmlyc3RPdGhlci5yZXRhaW4gLSBmaXJzdExlZnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgb3RoZXJJdGVyLm5leHQoZmlyc3RPdGhlci5yZXRhaW4gLSBmaXJzdExlZnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlbHRhID0gbmV3IERlbHRhKG9wcyk7XG4gICAgICAgIHdoaWxlICh0aGlzSXRlci5oYXNOZXh0KCkgfHwgb3RoZXJJdGVyLmhhc05leHQoKSkge1xuICAgICAgICAgICAgaWYgKG90aGVySXRlci5wZWVrVHlwZSgpID09PSAnaW5zZXJ0Jykge1xuICAgICAgICAgICAgICAgIGRlbHRhLnB1c2gob3RoZXJJdGVyLm5leHQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzSXRlci5wZWVrVHlwZSgpID09PSAnZGVsZXRlJykge1xuICAgICAgICAgICAgICAgIGRlbHRhLnB1c2godGhpc0l0ZXIubmV4dCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IE1hdGgubWluKHRoaXNJdGVyLnBlZWtMZW5ndGgoKSwgb3RoZXJJdGVyLnBlZWtMZW5ndGgoKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdGhpc09wID0gdGhpc0l0ZXIubmV4dChsZW5ndGgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG90aGVyT3AgPSBvdGhlckl0ZXIubmV4dChsZW5ndGgpO1xuICAgICAgICAgICAgICAgIGlmIChvdGhlck9wLnJldGFpbikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdPcCA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRoaXNPcC5yZXRhaW4gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdPcC5yZXRhaW4gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBvdGhlck9wLnJldGFpbiA9PT0gJ251bWJlcicgPyBsZW5ndGggOiBvdGhlck9wLnJldGFpbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb3RoZXJPcC5yZXRhaW4gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXNPcC5yZXRhaW4gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdPcC5pbnNlcnQgPSB0aGlzT3AuaW5zZXJ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3T3AucmV0YWluID0gdGhpc09wLnJldGFpbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhY3Rpb24gPSB0aGlzT3AucmV0YWluID09IG51bGwgPyAnaW5zZXJ0JyA6ICdyZXRhaW4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IFtlbWJlZFR5cGUsIHRoaXNEYXRhLCBvdGhlckRhdGFdID0gZ2V0RW1iZWRUeXBlQW5kRGF0YSh0aGlzT3BbYWN0aW9uXSwgb3RoZXJPcC5yZXRhaW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRsZXIgPSBEZWx0YS5nZXRIYW5kbGVyKGVtYmVkVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3T3BbYWN0aW9uXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2VtYmVkVHlwZV06IGhhbmRsZXIuY29tcG9zZSh0aGlzRGF0YSwgb3RoZXJEYXRhLCBhY3Rpb24gPT09ICdyZXRhaW4nKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFByZXNlcnZlIG51bGwgd2hlbiBjb21wb3Npbmcgd2l0aCBhIHJldGFpbiwgb3RoZXJ3aXNlIHJlbW92ZSBpdCBmb3IgaW5zZXJ0c1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0gQXR0cmlidXRlTWFwXzEuZGVmYXVsdC5jb21wb3NlKHRoaXNPcC5hdHRyaWJ1dGVzLCBvdGhlck9wLmF0dHJpYnV0ZXMsIHR5cGVvZiB0aGlzT3AucmV0YWluID09PSAnbnVtYmVyJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdPcC5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkZWx0YS5wdXNoKG5ld09wKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gT3B0aW1pemF0aW9uIGlmIHJlc3Qgb2Ygb3RoZXIgaXMganVzdCByZXRhaW5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFvdGhlckl0ZXIuaGFzTmV4dCgpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0VxdWFsKGRlbHRhLm9wc1tkZWx0YS5vcHMubGVuZ3RoIC0gMV0sIG5ld09wKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdCA9IG5ldyBEZWx0YSh0aGlzSXRlci5yZXN0KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlbHRhLmNvbmNhdChyZXN0KS5jaG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXIgb3Agc2hvdWxkIGJlIGRlbGV0ZSwgd2UgY291bGQgYmUgYW4gaW5zZXJ0IG9yIHJldGFpblxuICAgICAgICAgICAgICAgICAgICAvLyBJbnNlcnQgKyBkZWxldGUgY2FuY2VscyBvdXRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG90aGVyT3AuZGVsZXRlID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgICAgICAgICAgICAodHlwZW9mIHRoaXNPcC5yZXRhaW4gPT09ICdudW1iZXInIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mIHRoaXNPcC5yZXRhaW4gPT09ICdvYmplY3QnICYmIHRoaXNPcC5yZXRhaW4gIT09IG51bGwpKSkge1xuICAgICAgICAgICAgICAgICAgICBkZWx0YS5wdXNoKG90aGVyT3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVsdGEuY2hvcCgpO1xuICAgIH1cbiAgICBjb25jYXQob3RoZXIpIHtcbiAgICAgICAgY29uc3QgZGVsdGEgPSBuZXcgRGVsdGEodGhpcy5vcHMuc2xpY2UoKSk7XG4gICAgICAgIGlmIChvdGhlci5vcHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZGVsdGEucHVzaChvdGhlci5vcHNbMF0pO1xuICAgICAgICAgICAgZGVsdGEub3BzID0gZGVsdGEub3BzLmNvbmNhdChvdGhlci5vcHMuc2xpY2UoMSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWx0YTtcbiAgICB9XG4gICAgZGlmZihvdGhlciwgY3Vyc29yKSB7XG4gICAgICAgIGlmICh0aGlzLm9wcyA9PT0gb3RoZXIub3BzKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERlbHRhKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RyaW5ncyA9IFt0aGlzLCBvdGhlcl0ubWFwKChkZWx0YSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGRlbHRhXG4gICAgICAgICAgICAgICAgLm1hcCgob3ApID0+IHtcbiAgICAgICAgICAgICAgICBpZiAob3AuaW5zZXJ0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBvcC5pbnNlcnQgPT09ICdzdHJpbmcnID8gb3AuaW5zZXJ0IDogTlVMTF9DSEFSQUNURVI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHByZXAgPSBkZWx0YSA9PT0gb3RoZXIgPyAnb24nIDogJ3dpdGgnO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZGlmZigpIGNhbGxlZCAnICsgcHJlcCArICcgbm9uLWRvY3VtZW50Jyk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5qb2luKCcnKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJldERlbHRhID0gbmV3IERlbHRhKCk7XG4gICAgICAgIGNvbnN0IGRpZmZSZXN1bHQgPSBkaWZmKHN0cmluZ3NbMF0sIHN0cmluZ3NbMV0sIGN1cnNvciwgdHJ1ZSk7XG4gICAgICAgIGNvbnN0IHRoaXNJdGVyID0gbmV3IE9wSXRlcmF0b3JfMS5kZWZhdWx0KHRoaXMub3BzKTtcbiAgICAgICAgY29uc3Qgb3RoZXJJdGVyID0gbmV3IE9wSXRlcmF0b3JfMS5kZWZhdWx0KG90aGVyLm9wcyk7XG4gICAgICAgIGRpZmZSZXN1bHQuZm9yRWFjaCgoY29tcG9uZW50KSA9PiB7XG4gICAgICAgICAgICBsZXQgbGVuZ3RoID0gY29tcG9uZW50WzFdLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlIChsZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IG9wTGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGNvbXBvbmVudFswXSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIGRpZmYuSU5TRVJUOlxuICAgICAgICAgICAgICAgICAgICAgICAgb3BMZW5ndGggPSBNYXRoLm1pbihvdGhlckl0ZXIucGVla0xlbmd0aCgpLCBsZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0RGVsdGEucHVzaChvdGhlckl0ZXIubmV4dChvcExlbmd0aCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgZGlmZi5ERUxFVEU6XG4gICAgICAgICAgICAgICAgICAgICAgICBvcExlbmd0aCA9IE1hdGgubWluKGxlbmd0aCwgdGhpc0l0ZXIucGVla0xlbmd0aCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNJdGVyLm5leHQob3BMZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0RGVsdGEuZGVsZXRlKG9wTGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIGRpZmYuRVFVQUw6XG4gICAgICAgICAgICAgICAgICAgICAgICBvcExlbmd0aCA9IE1hdGgubWluKHRoaXNJdGVyLnBlZWtMZW5ndGgoKSwgb3RoZXJJdGVyLnBlZWtMZW5ndGgoKSwgbGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRoaXNPcCA9IHRoaXNJdGVyLm5leHQob3BMZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3RoZXJPcCA9IG90aGVySXRlci5uZXh0KG9wTGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0VxdWFsKHRoaXNPcC5pbnNlcnQsIG90aGVyT3AuaW5zZXJ0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldERlbHRhLnJldGFpbihvcExlbmd0aCwgQXR0cmlidXRlTWFwXzEuZGVmYXVsdC5kaWZmKHRoaXNPcC5hdHRyaWJ1dGVzLCBvdGhlck9wLmF0dHJpYnV0ZXMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldERlbHRhLnB1c2gob3RoZXJPcCkuZGVsZXRlKG9wTGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZW5ndGggLT0gb3BMZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmV0RGVsdGEuY2hvcCgpO1xuICAgIH1cbiAgICBlYWNoTGluZShwcmVkaWNhdGUsIG5ld2xpbmUgPSAnXFxuJykge1xuICAgICAgICBjb25zdCBpdGVyID0gbmV3IE9wSXRlcmF0b3JfMS5kZWZhdWx0KHRoaXMub3BzKTtcbiAgICAgICAgbGV0IGxpbmUgPSBuZXcgRGVsdGEoKTtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICB3aGlsZSAoaXRlci5oYXNOZXh0KCkpIHtcbiAgICAgICAgICAgIGlmIChpdGVyLnBlZWtUeXBlKCkgIT09ICdpbnNlcnQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdGhpc09wID0gaXRlci5wZWVrKCk7XG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IE9wXzEuZGVmYXVsdC5sZW5ndGgodGhpc09wKSAtIGl0ZXIucGVla0xlbmd0aCgpO1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSB0eXBlb2YgdGhpc09wLmluc2VydCA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgICA/IHRoaXNPcC5pbnNlcnQuaW5kZXhPZihuZXdsaW5lLCBzdGFydCkgLSBzdGFydFxuICAgICAgICAgICAgICAgIDogLTE7XG4gICAgICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgICAgICAgbGluZS5wdXNoKGl0ZXIubmV4dCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGluZGV4ID4gMCkge1xuICAgICAgICAgICAgICAgIGxpbmUucHVzaChpdGVyLm5leHQoaW5kZXgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChwcmVkaWNhdGUobGluZSwgaXRlci5uZXh0KDEpLmF0dHJpYnV0ZXMgfHwge30sIGkpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgICAgICBsaW5lID0gbmV3IERlbHRhKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbmUubGVuZ3RoKCkgPiAwKSB7XG4gICAgICAgICAgICBwcmVkaWNhdGUobGluZSwge30sIGkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGludmVydChiYXNlKSB7XG4gICAgICAgIGNvbnN0IGludmVydGVkID0gbmV3IERlbHRhKCk7XG4gICAgICAgIHRoaXMucmVkdWNlKChiYXNlSW5kZXgsIG9wKSA9PiB7XG4gICAgICAgICAgICBpZiAob3AuaW5zZXJ0KSB7XG4gICAgICAgICAgICAgICAgaW52ZXJ0ZWQuZGVsZXRlKE9wXzEuZGVmYXVsdC5sZW5ndGgob3ApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvcC5yZXRhaW4gPT09ICdudW1iZXInICYmIG9wLmF0dHJpYnV0ZXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGludmVydGVkLnJldGFpbihvcC5yZXRhaW4pO1xuICAgICAgICAgICAgICAgIHJldHVybiBiYXNlSW5kZXggKyBvcC5yZXRhaW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvcC5kZWxldGUgfHwgdHlwZW9mIG9wLnJldGFpbiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsZW5ndGggPSAob3AuZGVsZXRlIHx8IG9wLnJldGFpbik7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2xpY2UgPSBiYXNlLnNsaWNlKGJhc2VJbmRleCwgYmFzZUluZGV4ICsgbGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBzbGljZS5mb3JFYWNoKChiYXNlT3ApID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wLmRlbGV0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW52ZXJ0ZWQucHVzaChiYXNlT3ApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9wLnJldGFpbiAmJiBvcC5hdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnZlcnRlZC5yZXRhaW4oT3BfMS5kZWZhdWx0Lmxlbmd0aChiYXNlT3ApLCBBdHRyaWJ1dGVNYXBfMS5kZWZhdWx0LmludmVydChvcC5hdHRyaWJ1dGVzLCBiYXNlT3AuYXR0cmlidXRlcykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJhc2VJbmRleCArIGxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvcC5yZXRhaW4gPT09ICdvYmplY3QnICYmIG9wLnJldGFpbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNsaWNlID0gYmFzZS5zbGljZShiYXNlSW5kZXgsIGJhc2VJbmRleCArIDEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJhc2VPcCA9IG5ldyBPcEl0ZXJhdG9yXzEuZGVmYXVsdChzbGljZS5vcHMpLm5leHQoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBbZW1iZWRUeXBlLCBvcERhdGEsIGJhc2VPcERhdGFdID0gZ2V0RW1iZWRUeXBlQW5kRGF0YShvcC5yZXRhaW4sIGJhc2VPcC5pbnNlcnQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRsZXIgPSBEZWx0YS5nZXRIYW5kbGVyKGVtYmVkVHlwZSk7XG4gICAgICAgICAgICAgICAgaW52ZXJ0ZWQucmV0YWluKHsgW2VtYmVkVHlwZV06IGhhbmRsZXIuaW52ZXJ0KG9wRGF0YSwgYmFzZU9wRGF0YSkgfSwgQXR0cmlidXRlTWFwXzEuZGVmYXVsdC5pbnZlcnQob3AuYXR0cmlidXRlcywgYmFzZU9wLmF0dHJpYnV0ZXMpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYmFzZUluZGV4ICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBiYXNlSW5kZXg7XG4gICAgICAgIH0sIDApO1xuICAgICAgICByZXR1cm4gaW52ZXJ0ZWQuY2hvcCgpO1xuICAgIH1cbiAgICB0cmFuc2Zvcm0oYXJnLCBwcmlvcml0eSA9IGZhbHNlKSB7XG4gICAgICAgIHByaW9yaXR5ID0gISFwcmlvcml0eTtcbiAgICAgICAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1Qb3NpdGlvbihhcmcsIHByaW9yaXR5KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvdGhlciA9IGFyZztcbiAgICAgICAgY29uc3QgdGhpc0l0ZXIgPSBuZXcgT3BJdGVyYXRvcl8xLmRlZmF1bHQodGhpcy5vcHMpO1xuICAgICAgICBjb25zdCBvdGhlckl0ZXIgPSBuZXcgT3BJdGVyYXRvcl8xLmRlZmF1bHQob3RoZXIub3BzKTtcbiAgICAgICAgY29uc3QgZGVsdGEgPSBuZXcgRGVsdGEoKTtcbiAgICAgICAgd2hpbGUgKHRoaXNJdGVyLmhhc05leHQoKSB8fCBvdGhlckl0ZXIuaGFzTmV4dCgpKSB7XG4gICAgICAgICAgICBpZiAodGhpc0l0ZXIucGVla1R5cGUoKSA9PT0gJ2luc2VydCcgJiZcbiAgICAgICAgICAgICAgICAocHJpb3JpdHkgfHwgb3RoZXJJdGVyLnBlZWtUeXBlKCkgIT09ICdpbnNlcnQnKSkge1xuICAgICAgICAgICAgICAgIGRlbHRhLnJldGFpbihPcF8xLmRlZmF1bHQubGVuZ3RoKHRoaXNJdGVyLm5leHQoKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob3RoZXJJdGVyLnBlZWtUeXBlKCkgPT09ICdpbnNlcnQnKSB7XG4gICAgICAgICAgICAgICAgZGVsdGEucHVzaChvdGhlckl0ZXIubmV4dCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IE1hdGgubWluKHRoaXNJdGVyLnBlZWtMZW5ndGgoKSwgb3RoZXJJdGVyLnBlZWtMZW5ndGgoKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdGhpc09wID0gdGhpc0l0ZXIubmV4dChsZW5ndGgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG90aGVyT3AgPSBvdGhlckl0ZXIubmV4dChsZW5ndGgpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzT3AuZGVsZXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE91ciBkZWxldGUgZWl0aGVyIG1ha2VzIHRoZWlyIGRlbGV0ZSByZWR1bmRhbnQgb3IgcmVtb3ZlcyB0aGVpciByZXRhaW5cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG90aGVyT3AuZGVsZXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbHRhLnB1c2gob3RoZXJPcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0aGlzRGF0YSA9IHRoaXNPcC5yZXRhaW47XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG90aGVyRGF0YSA9IG90aGVyT3AucmV0YWluO1xuICAgICAgICAgICAgICAgICAgICBsZXQgdHJhbnNmb3JtZWREYXRhID0gdHlwZW9mIG90aGVyRGF0YSA9PT0gJ29iamVjdCcgJiYgb3RoZXJEYXRhICE9PSBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICA/IG90aGVyRGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBsZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpc0RhdGEgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzRGF0YSAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIG90aGVyRGF0YSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIG90aGVyRGF0YSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZW1iZWRUeXBlID0gT2JqZWN0LmtleXModGhpc0RhdGEpWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVtYmVkVHlwZSA9PT0gT2JqZWN0LmtleXMob3RoZXJEYXRhKVswXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRsZXIgPSBEZWx0YS5nZXRIYW5kbGVyKGVtYmVkVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtZWREYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2VtYmVkVHlwZV06IGhhbmRsZXIudHJhbnNmb3JtKHRoaXNEYXRhW2VtYmVkVHlwZV0sIG90aGVyRGF0YVtlbWJlZFR5cGVdLCBwcmlvcml0eSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIHJldGFpbiBlaXRoZXIgdGhlaXIgcmV0YWluIG9yIGluc2VydFxuICAgICAgICAgICAgICAgICAgICBkZWx0YS5yZXRhaW4odHJhbnNmb3JtZWREYXRhLCBBdHRyaWJ1dGVNYXBfMS5kZWZhdWx0LnRyYW5zZm9ybSh0aGlzT3AuYXR0cmlidXRlcywgb3RoZXJPcC5hdHRyaWJ1dGVzLCBwcmlvcml0eSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVsdGEuY2hvcCgpO1xuICAgIH1cbiAgICB0cmFuc2Zvcm1Qb3NpdGlvbihpbmRleCwgcHJpb3JpdHkgPSBmYWxzZSkge1xuICAgICAgICBwcmlvcml0eSA9ICEhcHJpb3JpdHk7XG4gICAgICAgIGNvbnN0IHRoaXNJdGVyID0gbmV3IE9wSXRlcmF0b3JfMS5kZWZhdWx0KHRoaXMub3BzKTtcbiAgICAgICAgbGV0IG9mZnNldCA9IDA7XG4gICAgICAgIHdoaWxlICh0aGlzSXRlci5oYXNOZXh0KCkgJiYgb2Zmc2V0IDw9IGluZGV4KSB7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSB0aGlzSXRlci5wZWVrTGVuZ3RoKCk7XG4gICAgICAgICAgICBjb25zdCBuZXh0VHlwZSA9IHRoaXNJdGVyLnBlZWtUeXBlKCk7XG4gICAgICAgICAgICB0aGlzSXRlci5uZXh0KCk7XG4gICAgICAgICAgICBpZiAobmV4dFR5cGUgPT09ICdkZWxldGUnKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggLT0gTWF0aC5taW4obGVuZ3RoLCBpbmRleCAtIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChuZXh0VHlwZSA9PT0gJ2luc2VydCcgJiYgKG9mZnNldCA8IGluZGV4IHx8ICFwcmlvcml0eSkpIHtcbiAgICAgICAgICAgICAgICBpbmRleCArPSBsZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmZzZXQgKz0gbGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG59XG5EZWx0YS5PcCA9IE9wXzEuZGVmYXVsdDtcbkRlbHRhLk9wSXRlcmF0b3IgPSBPcEl0ZXJhdG9yXzEuZGVmYXVsdDtcbkRlbHRhLkF0dHJpYnV0ZU1hcCA9IEF0dHJpYnV0ZU1hcF8xLmRlZmF1bHQ7XG5EZWx0YS5oYW5kbGVycyA9IHt9O1xuZXhwb3J0cy5kZWZhdWx0ID0gRGVsdGE7XG5pZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IERlbHRhO1xuICAgIG1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBEZWx0YTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURlbHRhLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/quill-delta/dist/Delta.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/quill-delta/dist/Op.js":
/*!*********************************************!*\
  !*** ./node_modules/quill-delta/dist/Op.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar Op;\n(function (Op) {\n    function length(op) {\n        if (typeof op.delete === 'number') {\n            return op.delete;\n        }\n        else if (typeof op.retain === 'number') {\n            return op.retain;\n        }\n        else if (typeof op.retain === 'object' && op.retain !== null) {\n            return 1;\n        }\n        else {\n            return typeof op.insert === 'string' ? op.insert.length : 1;\n        }\n    }\n    Op.length = length;\n})(Op || (Op = {}));\nexports[\"default\"] = Op;\n//# sourceMappingURL=Op.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcXVpbGwtZGVsdGEvZGlzdC9PcC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnQkFBZ0I7QUFDakIsa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsid2VicGFjazovL2RvY2Fzc2lzdC8uL25vZGVfbW9kdWxlcy9xdWlsbC1kZWx0YS9kaXN0L09wLmpzPzNjMWYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgT3A7XG4oZnVuY3Rpb24gKE9wKSB7XG4gICAgZnVuY3Rpb24gbGVuZ3RoKG9wKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb3AuZGVsZXRlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIG9wLmRlbGV0ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb3AucmV0YWluID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIG9wLnJldGFpbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb3AucmV0YWluID09PSAnb2JqZWN0JyAmJiBvcC5yZXRhaW4gIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBvcC5pbnNlcnQgPT09ICdzdHJpbmcnID8gb3AuaW5zZXJ0Lmxlbmd0aCA6IDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgT3AubGVuZ3RoID0gbGVuZ3RoO1xufSkoT3AgfHwgKE9wID0ge30pKTtcbmV4cG9ydHMuZGVmYXVsdCA9IE9wO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9T3AuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/quill-delta/dist/Op.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/quill-delta/dist/OpIterator.js":
/*!*****************************************************!*\
  !*** ./node_modules/quill-delta/dist/OpIterator.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst Op_1 = __webpack_require__(/*! ./Op */ \"(ssr)/./node_modules/quill-delta/dist/Op.js\");\nclass Iterator {\n    constructor(ops) {\n        this.ops = ops;\n        this.index = 0;\n        this.offset = 0;\n    }\n    hasNext() {\n        return this.peekLength() < Infinity;\n    }\n    next(length) {\n        if (!length) {\n            length = Infinity;\n        }\n        const nextOp = this.ops[this.index];\n        if (nextOp) {\n            const offset = this.offset;\n            const opLength = Op_1.default.length(nextOp);\n            if (length >= opLength - offset) {\n                length = opLength - offset;\n                this.index += 1;\n                this.offset = 0;\n            }\n            else {\n                this.offset += length;\n            }\n            if (typeof nextOp.delete === 'number') {\n                return { delete: length };\n            }\n            else {\n                const retOp = {};\n                if (nextOp.attributes) {\n                    retOp.attributes = nextOp.attributes;\n                }\n                if (typeof nextOp.retain === 'number') {\n                    retOp.retain = length;\n                }\n                else if (typeof nextOp.retain === 'object' &&\n                    nextOp.retain !== null) {\n                    // offset should === 0, length should === 1\n                    retOp.retain = nextOp.retain;\n                }\n                else if (typeof nextOp.insert === 'string') {\n                    retOp.insert = nextOp.insert.substr(offset, length);\n                }\n                else {\n                    // offset should === 0, length should === 1\n                    retOp.insert = nextOp.insert;\n                }\n                return retOp;\n            }\n        }\n        else {\n            return { retain: Infinity };\n        }\n    }\n    peek() {\n        return this.ops[this.index];\n    }\n    peekLength() {\n        if (this.ops[this.index]) {\n            // Should never return 0 if our index is being managed correctly\n            return Op_1.default.length(this.ops[this.index]) - this.offset;\n        }\n        else {\n            return Infinity;\n        }\n    }\n    peekType() {\n        const op = this.ops[this.index];\n        if (op) {\n            if (typeof op.delete === 'number') {\n                return 'delete';\n            }\n            else if (typeof op.retain === 'number' ||\n                (typeof op.retain === 'object' && op.retain !== null)) {\n                return 'retain';\n            }\n            else {\n                return 'insert';\n            }\n        }\n        return 'retain';\n    }\n    rest() {\n        if (!this.hasNext()) {\n            return [];\n        }\n        else if (this.offset === 0) {\n            return this.ops.slice(this.index);\n        }\n        else {\n            const offset = this.offset;\n            const index = this.index;\n            const next = this.next();\n            const rest = this.ops.slice(this.index);\n            this.offset = offset;\n            this.index = index;\n            return [next].concat(rest);\n        }\n    }\n}\nexports[\"default\"] = Iterator;\n//# sourceMappingURL=OpIterator.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcXVpbGwtZGVsdGEvZGlzdC9PcEl0ZXJhdG9yLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsbUJBQU8sQ0FBQyx5REFBTTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kb2Nhc3Npc3QvLi9ub2RlX21vZHVsZXMvcXVpbGwtZGVsdGEvZGlzdC9PcEl0ZXJhdG9yLmpzP2JlNjAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBPcF8xID0gcmVxdWlyZShcIi4vT3BcIik7XG5jbGFzcyBJdGVyYXRvciB7XG4gICAgY29uc3RydWN0b3Iob3BzKSB7XG4gICAgICAgIHRoaXMub3BzID0gb3BzO1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSAwO1xuICAgIH1cbiAgICBoYXNOZXh0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wZWVrTGVuZ3RoKCkgPCBJbmZpbml0eTtcbiAgICB9XG4gICAgbmV4dChsZW5ndGgpIHtcbiAgICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgICAgIGxlbmd0aCA9IEluZmluaXR5O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5leHRPcCA9IHRoaXMub3BzW3RoaXMuaW5kZXhdO1xuICAgICAgICBpZiAobmV4dE9wKSB7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgICAgIGNvbnN0IG9wTGVuZ3RoID0gT3BfMS5kZWZhdWx0Lmxlbmd0aChuZXh0T3ApO1xuICAgICAgICAgICAgaWYgKGxlbmd0aCA+PSBvcExlbmd0aCAtIG9mZnNldCkge1xuICAgICAgICAgICAgICAgIGxlbmd0aCA9IG9wTGVuZ3RoIC0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggKz0gMTtcbiAgICAgICAgICAgICAgICB0aGlzLm9mZnNldCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9mZnNldCArPSBsZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIG5leHRPcC5kZWxldGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGVsZXRlOiBsZW5ndGggfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJldE9wID0ge307XG4gICAgICAgICAgICAgICAgaWYgKG5leHRPcC5hdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldE9wLmF0dHJpYnV0ZXMgPSBuZXh0T3AuYXR0cmlidXRlcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBuZXh0T3AucmV0YWluID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICByZXRPcC5yZXRhaW4gPSBsZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBuZXh0T3AucmV0YWluID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgICAgICBuZXh0T3AucmV0YWluICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG9mZnNldCBzaG91bGQgPT09IDAsIGxlbmd0aCBzaG91bGQgPT09IDFcbiAgICAgICAgICAgICAgICAgICAgcmV0T3AucmV0YWluID0gbmV4dE9wLnJldGFpbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG5leHRPcC5pbnNlcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldE9wLmluc2VydCA9IG5leHRPcC5pbnNlcnQuc3Vic3RyKG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG9mZnNldCBzaG91bGQgPT09IDAsIGxlbmd0aCBzaG91bGQgPT09IDFcbiAgICAgICAgICAgICAgICAgICAgcmV0T3AuaW5zZXJ0ID0gbmV4dE9wLmluc2VydDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldE9wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHsgcmV0YWluOiBJbmZpbml0eSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHBlZWsoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wc1t0aGlzLmluZGV4XTtcbiAgICB9XG4gICAgcGVla0xlbmd0aCgpIHtcbiAgICAgICAgaWYgKHRoaXMub3BzW3RoaXMuaW5kZXhdKSB7XG4gICAgICAgICAgICAvLyBTaG91bGQgbmV2ZXIgcmV0dXJuIDAgaWYgb3VyIGluZGV4IGlzIGJlaW5nIG1hbmFnZWQgY29ycmVjdGx5XG4gICAgICAgICAgICByZXR1cm4gT3BfMS5kZWZhdWx0Lmxlbmd0aCh0aGlzLm9wc1t0aGlzLmluZGV4XSkgLSB0aGlzLm9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwZWVrVHlwZSgpIHtcbiAgICAgICAgY29uc3Qgb3AgPSB0aGlzLm9wc1t0aGlzLmluZGV4XTtcbiAgICAgICAgaWYgKG9wKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wLmRlbGV0ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2RlbGV0ZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb3AucmV0YWluID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgICAgICAgICh0eXBlb2Ygb3AucmV0YWluID09PSAnb2JqZWN0JyAmJiBvcC5yZXRhaW4gIT09IG51bGwpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdyZXRhaW4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdpbnNlcnQnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAncmV0YWluJztcbiAgICB9XG4gICAgcmVzdCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc05leHQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMub2Zmc2V0ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcHMuc2xpY2UodGhpcy5pbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5pbmRleDtcbiAgICAgICAgICAgIGNvbnN0IG5leHQgPSB0aGlzLm5leHQoKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3QgPSB0aGlzLm9wcy5zbGljZSh0aGlzLmluZGV4KTtcbiAgICAgICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgcmV0dXJuIFtuZXh0XS5jb25jYXQocmVzdCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBJdGVyYXRvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU9wSXRlcmF0b3IuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/quill-delta/dist/OpIterator.js\n");

/***/ })

};
;